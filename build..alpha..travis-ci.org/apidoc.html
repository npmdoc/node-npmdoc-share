<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/josephg/sharejs"

    >share (v0.7.40)</a>
</h1>
<h4>A database for concurrent document editing</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.share">module share</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection">
            function <span class="apidocSignatureSpan">share.</span>client.Connection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc">
            function <span class="apidocSignatureSpan">share.</span>client.Doc
            <span class="apidocSignatureSpan">(connection, collection, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client">
            function <span class="apidocSignatureSpan">share.</span>db.client
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver">
            function <span class="apidocSignatureSpan">share.</span>db.inprocessDriver
            <span class="apidocSignatureSpan">(oplog)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory">
            function <span class="apidocSignatureSpan">share.</span>db.memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver">
            function <span class="apidocSignatureSpan">share.</span>db.redisDriver
            <span class="apidocSignatureSpan">(oplog, client, observer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session">
            function <span class="apidocSignatureSpan">share.</span>session
            <span class="apidocSignatureSpan">(instance, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent">
            function <span class="apidocSignatureSpan">share.</span>useragent
            <span class="apidocSignatureSpan">(instance, stream)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>client.Connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>client.Doc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>connection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db.client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db.inprocessDriver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db.memory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db.ot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>db.redisDriver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>emitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>query</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>session.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.</span>useragent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">share.</span>scriptsDir</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.client">module share.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection">
            function <span class="apidocSignatureSpan">share.client.</span>Connection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc">
            function <span class="apidocSignatureSpan">share.client.</span>Doc
            <span class="apidocSignatureSpan">(connection, collection, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.registerType">
            function <span class="apidocSignatureSpan">share.client.</span>registerType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.client.</span>ottypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.client.Connection">module share.client.Connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.Connection">
            function <span class="apidocSignatureSpan">share.client.</span>Connection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.client.Connection.prototype">module share.client.Connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._addDoc">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_addDoc
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._createQuery">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_createQuery
            <span class="apidocSignatureSpan">(type, collection, q, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._destroyDoc">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_destroyDoc
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._destroyQuery">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_destroyQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._setState">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_setState
            <span class="apidocSignatureSpan">(newState, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype._setupRetry">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_setupRetry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.addListener">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.bindToSocket">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bindToSocket
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.bsEnd">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bsEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.bsStart">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bsStart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.createFetchQuery">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>createFetchQuery
            <span class="apidocSignatureSpan">(index, q, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.createSubscribeQuery">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>createSubscribeQuery
            <span class="apidocSignatureSpan">(index, q, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.disconnect">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.emit">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.eventNames">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.get">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>get
            <span class="apidocSignatureSpan">(collection, name, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.getExisting">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getExisting
            <span class="apidocSignatureSpan">(collection, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.getMaxListeners">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.getOrCreate">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getOrCreate
            <span class="apidocSignatureSpan">(collection, name, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.handleMessage">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>handleMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.listenerCount">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.listeners">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.on">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.once">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.prependListener">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.prependOnceListener">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.removeListener">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.reset">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.send">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>send
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.sendFetch">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendFetch
            <span class="apidocSignatureSpan">(doc, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.sendOp">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendOp
            <span class="apidocSignatureSpan">(doc, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.sendSubscribe">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendSubscribe
            <span class="apidocSignatureSpan">(doc, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.sendUnsubscribe">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendUnsubscribe
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Connection.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">undefined <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>domain</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.client.Doc">module share.client.Doc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.Doc">
            function <span class="apidocSignatureSpan">share.client.</span>Doc
            <span class="apidocSignatureSpan">(connection, collection, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.client.Doc.prototype">module share.client.Doc.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._clearAction">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_clearAction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._clearInflightOp">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_clearInflightOp
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._emitNothingPending">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_emitNothingPending
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._finishSub">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_finishSub
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._getLatestOps">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_getLatestOps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._handleSubscribe">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_handleSubscribe
            <span class="apidocSignatureSpan">(err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._onConnectionStateChanged">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_onConnectionStateChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._onMessage">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_onMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._opAcknowledged">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_opAcknowledged
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._otApply">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_otApply
            <span class="apidocSignatureSpan">(opData, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._sendOpData">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_sendOpData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._setType">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_setType
            <span class="apidocSignatureSpan">(newType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._setWantSubscribe">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_setWantSubscribe
            <span class="apidocSignatureSpan">(value, callback, err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._submitOpData">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_submitOpData
            <span class="apidocSignatureSpan">(opData, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype._tryRollback">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_tryRollback
            <span class="apidocSignatureSpan">(opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.addListener">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.attachTextarea">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>attachTextarea
            <span class="apidocSignatureSpan">(elem, ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.create">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>create
            <span class="apidocSignatureSpan">(type, data, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.createContext">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>createContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.del">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>del
            <span class="apidocSignatureSpan">(context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.destroy">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>destroy
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.emit">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.eventNames">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.fetch">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>fetch
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.flush">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.getMaxListeners">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.getSnapshot">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>getSnapshot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.hasPending">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>hasPending
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.ingestData">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>ingestData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.listenerCount">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.listeners">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.on">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.once">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.pause">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.prependListener">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.prependOnceListener">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.removeContexts">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeContexts
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.removeListener">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.resume">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.retry">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.submitOp">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>submitOp
            <span class="apidocSignatureSpan">(op, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.subscribe">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.client.Doc.prototype.whenReady">
            function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>whenReady
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">undefined <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>domain</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.connection">module share.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.connection.Connection">
            function <span class="apidocSignatureSpan">share.connection.</span>Connection
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db">module share.db</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client">
            function <span class="apidocSignatureSpan">share.db.</span>client
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver">
            function <span class="apidocSignatureSpan">share.db.</span>inprocessDriver
            <span class="apidocSignatureSpan">(oplog)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory">
            function <span class="apidocSignatureSpan">share.db.</span>memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver">
            function <span class="apidocSignatureSpan">share.db.</span>redisDriver
            <span class="apidocSignatureSpan">(oplog, client, observer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.db.</span>ot</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.client">module share.db.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.client">
            function <span class="apidocSignatureSpan">share.db.</span>client
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.client.prototype">module share.db.client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._bulkSubscribeProjection">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_bulkSubscribeProjection
            <span class="apidocSignatureSpan">(cName, docs, projection, results, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._dbQuery">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_dbQuery
            <span class="apidocSignatureSpan">(db, index, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._dbQueryDoc">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_dbQueryDoc
            <span class="apidocSignatureSpan">(db, index, docName, query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._fetchPresence">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_fetchPresence
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._getSnapshot">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_getSnapshot
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._lazyFetch">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_lazyFetch
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._sdcDbPrefix">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_sdcDbPrefix
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._trySubmit">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_trySubmit
            <span class="apidocSignatureSpan">(submitData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._updateCursors">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_updateCursors
            <span class="apidocSignatureSpan">(cName, docName, type, opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype._writeSnapshotAfterSubmit">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_writeSnapshotAfterSubmit
            <span class="apidocSignatureSpan">(cName, docName, snapshot, opData, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.addProjection">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>addProjection
            <span class="apidocSignatureSpan">(projName, cName, type, fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.bulkFetch">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>bulkFetch
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.bulkSubscribe">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>bulkSubscribe
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.collection">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>collection
            <span class="apidocSignatureSpan">(cName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.consumeDirtyData">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>consumeDirtyData
            <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.destroy">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.fetch">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetch
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.fetchAndSubscribe">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetchAndSubscribe
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.fetchPresence">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetchPresence
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.getOps">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>getOps
            <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.query">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>query
            <span class="apidocSignatureSpan">(index, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.queryFetch">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>queryFetch
            <span class="apidocSignatureSpan">(index, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.queryPoll">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>queryPoll
            <span class="apidocSignatureSpan">(index, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.submit">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>submit
            <span class="apidocSignatureSpan">(cName, docName, opData, submitOptions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.submitPresence">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>submitPresence
            <span class="apidocSignatureSpan">(cName, docName, pOp, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.client.prototype.subscribe">
            function <span class="apidocSignatureSpan">share.db.client.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(cName, docName, v, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.inprocessDriver">module share.db.inprocessDriver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.inprocessDriver">
            function <span class="apidocSignatureSpan">share.db.</span>inprocessDriver
            <span class="apidocSignatureSpan">(oplog)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.inprocessDriver.prototype">module share.db.inprocessDriver.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>distributed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype._checkForLeaks">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_checkForLeaks
            <span class="apidocSignatureSpan">(allowSubscriptions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype._cleanupStream">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_cleanupStream
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype._createStream">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_createStream
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype._getOpsSince">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_getOpsSince
            <span class="apidocSignatureSpan">(cName, docName, version, results, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype._subscribeNow">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_subscribeNow
            <span class="apidocSignatureSpan">(cName, docName, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.appendDirtyData">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>appendDirtyData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.atomicSubmit">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>atomicSubmit
            <span class="apidocSignatureSpan">(cName, docName, opData, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.bulkGetOpsSince">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>bulkGetOpsSince
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.bulkSubscribe">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>bulkSubscribe
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.consumeDirtyData">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>consumeDirtyData
            <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.destroy">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.getOps">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>getOps
            <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.postSubmit">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>postSubmit
            <span class="apidocSignatureSpan">(cName, docName, opData, snapshot, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.subscribe">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(cName, docName, v, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.inprocessDriver.prototype.subscribeCollection">
            function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>subscribeCollection
            <span class="apidocSignatureSpan">(cName, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.memory">module share.db.memory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.memory">
            function <span class="apidocSignatureSpan">share.db.</span>memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.memory.prototype">module share.db.memory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype._getOpLog">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>_getOpLog
            <span class="apidocSignatureSpan">(cName, docName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype._getSnapshotSync">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>_getSnapshotSync
            <span class="apidocSignatureSpan">(cName, docName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.bulkGetSnapshot">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>bulkGetSnapshot
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.close">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.getOps">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getOps
            <span class="apidocSignatureSpan">(cName, docName, start, end, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.getSnapshot">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getSnapshot
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.getVersion">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getVersion
            <span class="apidocSignatureSpan">(cName, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.query">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>query
            <span class="apidocSignatureSpan">(liveDb, index, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.queryDoc">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>queryDoc
            <span class="apidocSignatureSpan">(liveDb, index, cName, docName, query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.queryNeedsPollMode">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>queryNeedsPollMode
            <span class="apidocSignatureSpan">(index, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.writeOp">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>writeOp
            <span class="apidocSignatureSpan">(cName, docName, opData, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.memory.prototype.writeSnapshot">
            function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>writeSnapshot
            <span class="apidocSignatureSpan">(cName, docName, snapshot, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.ot">module share.db.ot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.apply">
            function <span class="apidocSignatureSpan">share.db.ot.</span>apply
            <span class="apidocSignatureSpan">(data, opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.applyAll">
            function <span class="apidocSignatureSpan">share.db.ot.</span>applyAll
            <span class="apidocSignatureSpan">(data, ops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.applyPresence">
            function <span class="apidocSignatureSpan">share.db.ot.</span>applyPresence
            <span class="apidocSignatureSpan">(p, pOp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.checkOpData">
            function <span class="apidocSignatureSpan">share.db.ot.</span>checkOpData
            <span class="apidocSignatureSpan">(opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.normalize">
            function <span class="apidocSignatureSpan">share.db.ot.</span>normalize
            <span class="apidocSignatureSpan">(opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.normalizeType">
            function <span class="apidocSignatureSpan">share.db.ot.</span>normalizeType
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.registerType">
            function <span class="apidocSignatureSpan">share.db.ot.</span>registerType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.transform">
            function <span class="apidocSignatureSpan">share.db.ot.</span>transform
            <span class="apidocSignatureSpan">(type, opData, appliedOpData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.transformPresence">
            function <span class="apidocSignatureSpan">share.db.ot.</span>transformPresence
            <span class="apidocSignatureSpan">(type, p, pOp, opData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.ot.updatePresence">
            function <span class="apidocSignatureSpan">share.db.ot.</span>updatePresence
            <span class="apidocSignatureSpan">(type, p, opData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.redisDriver">module share.db.redisDriver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.redisDriver">
            function <span class="apidocSignatureSpan">share.db.</span>redisDriver
            <span class="apidocSignatureSpan">(oplog, client, observer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.db.redisDriver.prototype">module share.db.redisDriver.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>distributed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._checkForLeaks">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_checkForLeaks
            <span class="apidocSignatureSpan">(allowSubscriptions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._createStream">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_createStream
            <span class="apidocSignatureSpan">(channel, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._finishBulkSubscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_finishBulkSubscribe
            <span class="apidocSignatureSpan">(streams, requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._finishSubscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_finishSubscribe
            <span class="apidocSignatureSpan">(stream, cName, docName, version, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._getCollectionChannel">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_getCollectionChannel
            <span class="apidocSignatureSpan">(cName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._getDocChannel">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_getDocChannel
            <span class="apidocSignatureSpan">(cName, docName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._oplogGetOps">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_oplogGetOps
            <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._prefixChannel">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_prefixChannel
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisCacheVersion">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisCacheVersion
            <span class="apidocSignatureSpan">(cName, docName, v, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisGetOps">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisGetOps
            <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisSetExpire">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSetExpire
            <span class="apidocSignatureSpan">(cName, docName, v, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisSubmitScript">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSubmitScript
            <span class="apidocSignatureSpan">(cName, docName, opData, dirtyData, docVersion, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisSubscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSubscribe
            <span class="apidocSignatureSpan">(channel, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._redisUnsubscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisUnsubscribe
            <span class="apidocSignatureSpan">(channel, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._removeStream">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_removeStream
            <span class="apidocSignatureSpan">(channel, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype._writeOpToLog">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_writeOpToLog
            <span class="apidocSignatureSpan">(cName, docName, opData, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.atomicSubmit">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>atomicSubmit
            <span class="apidocSignatureSpan">(cName, docName, opData, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.bulkGetOpsSince">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>bulkGetOpsSince
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.bulkSubscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>bulkSubscribe
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.consumeDirtyData">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>consumeDirtyData
            <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.destroy">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.getOps">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>getOps
            <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.postSubmit">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>postSubmit
            <span class="apidocSignatureSpan">(cName, docName, opData, snapshot, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.subscribe">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(cName, docName, version, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.db.redisDriver.prototype.subscribeCollection">
            function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>subscribeCollection
            <span class="apidocSignatureSpan">(cName, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.emitter">module share.emitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.emitter.EventEmitter">
            function <span class="apidocSignatureSpan">share.emitter.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.emitter.mixin">
            function <span class="apidocSignatureSpan">share.emitter.</span>mixin
            <span class="apidocSignatureSpan">(Constructor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.query">module share.query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.query.Query">
            function <span class="apidocSignatureSpan">share.query.</span>Query
            <span class="apidocSignatureSpan">(type, connection, id, collection, query, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.server">module share.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.server.createClient">
            function <span class="apidocSignatureSpan">share.server.</span>createClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.session">module share.session</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.session">
            function <span class="apidocSignatureSpan">share.</span>session
            <span class="apidocSignatureSpan">(instance, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.session.prototype">module share.session.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._cancelBulk">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_cancelBulk
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._checkRequest">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_checkRequest
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._cleanup">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._handleMessage">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_handleMessage
            <span class="apidocSignatureSpan">(req, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._isSubscribed">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_isSubscribed
            <span class="apidocSignatureSpan">(c, docName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._processQueryResults">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_processQueryResults
            <span class="apidocSignatureSpan">(collection, results, qopts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._reply">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_reply
            <span class="apidocSignatureSpan">(req, err, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._send">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_send
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._sendOp">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_sendOp
            <span class="apidocSignatureSpan">(collection, docName, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._setSubscribed">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_setSubscribed
            <span class="apidocSignatureSpan">(collection, docName, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._subscribe">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(collection, docName, v, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype._subscribeToStream">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>_subscribeToStream
            <span class="apidocSignatureSpan">(collection, docName, opstream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype.bulkSubscribe">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>bulkSubscribe
            <span class="apidocSignatureSpan">(request, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype.close">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>close
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype.pump">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>pump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.session.prototype.subscribeStats">
            function <span class="apidocSignatureSpan">share.session.prototype.</span>subscribeStats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.types">module share.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.types.registerType">
            function <span class="apidocSignatureSpan">share.types.</span>registerType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">share.types.</span>ottypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.useragent">module share.useragent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.useragent">
            function <span class="apidocSignatureSpan">share.</span>useragent
            <span class="apidocSignatureSpan">(instance, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.share.useragent.prototype">module share.useragent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype._filterQueryResults">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>_filterQueryResults
            <span class="apidocSignatureSpan">(collection, results, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype._runFilters">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>_runFilters
            <span class="apidocSignatureSpan">(filters, collection, docName, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.bulkFetch">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>bulkFetch
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.bulkSubscribe">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>bulkSubscribe
            <span class="apidocSignatureSpan">(requests, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.fetch">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>fetch
            <span class="apidocSignatureSpan">(collection, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.fetchAndSubscribe">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>fetchAndSubscribe
            <span class="apidocSignatureSpan">(collection, docName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.filterDoc">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterDoc
            <span class="apidocSignatureSpan">(collection, docName, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.filterDocs">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterDocs
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.filterOp">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterOp
            <span class="apidocSignatureSpan">(collection, docName, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.filterOps">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterOps
            <span class="apidocSignatureSpan">(collection, docName, ops, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.getOps">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>getOps
            <span class="apidocSignatureSpan">(collection, docName, start, end, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.query">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>query
            <span class="apidocSignatureSpan">(collection, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.queryFetch">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>queryFetch
            <span class="apidocSignatureSpan">(collection, query, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.submit">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>submit
            <span class="apidocSignatureSpan">(collection, docName, opData, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.subscribe">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(collection, docName, version, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.trigger">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>trigger
            <span class="apidocSignatureSpan">(action, collection, docName, request, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.wrapOpStream">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>wrapOpStream
            <span class="apidocSignatureSpan">(collection, docName, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.share.useragent.prototype.wrapOpStreams">
            function <span class="apidocSignatureSpan">share.useragent.prototype.</span>wrapOpStreams
            <span class="apidocSignatureSpan">(streams)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share" id="apidoc.module.share">module share</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Connection" id="apidoc.element.share.client.Connection">
        function <span class="apidocSignatureSpan">share.</span>client.Connection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">client.Connection = function (socket) {
  emitter.EventEmitter.call(this);

  // Map of collection -&#x3e; docName -&#x3e; doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -&#x3e; query object.
  this.queries = {};

  // State of the connection. The correspoding events are emmited when this
  // changes. Available states are:
  // - &#x27;connecting&#x27;   The connection has been established, but we don&#x27;t have our
  //                  client ID yet
  // - &#x27;connected&#x27;    We have connected and recieved our client ID. Ready for data.
  // - &#x27;disconnected&#x27; The connection is closed, but it will reconnect automatically.
  // - &#x27;stopped&#x27;      The connection is closed, and should not reconnect.
  this.state = &#x27;disconnected&#x27;;

  // This is a helper variable the document uses to see whether we&#x27;re currently
  // in a &#x27;live&#x27; state. It is true if we&#x27;re connected, or if you&#x27;re using
  // browserchannel and connecting.
  this.canSend = false;

  // Private variable to support clearing of op retry interval
  this._retryInterval = null;

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  // I&#x27;ll store the most recent 100 messages so when errors occur we can see
  // what happened.
  this.messageBuffer = [];

  this.bindToSocket(socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Client API

The client API can be used either from nodejs or from a browser.

From the server:

```javascript
var connection = require(&#x27;share&#x27;).<span class="apidocCodeKeywordSpan">client.Connection</span>(socket);
```

From the browser, you&#x27;ll need to first include the sharejs library. You can use
browserify and require(&#x27;share&#x27;).client or include the script directly.

The browser library is built to the `node_modules/share/webclient` directory
when you install sharejs. This path is exposed programatically at
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc" id="apidoc.element.share.client.Doc">
        function <span class="apidocSignatureSpan">share.</span>client.Doc
        <span class="apidocSignatureSpan">(connection, collection, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">client.Doc = function (connection, collection, name) {
  emitter.EventEmitter.call(this);

  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;
  this.snapshot = undefined;

  // **** State in document:

  // The action the document tries to perform with the server
  //
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit: send an operation
  this.action = null;

  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don&#x27;t know whats going on.
  //   - Floating (&#x27;floating&#x27;): we have a locally created document that hasn&#x27;t
  //     been created on the server yet)
  //   - Live (&#x27;ready&#x27;) (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we&#x27;re subscribed on the server, or we aren&#x27;t.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server (&#x27;fetch&#x27;), or we don&#x27;t care (false). This is also used when we
  // disconnect &#x26; reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we&#x27;ll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn&#x27;t provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];

  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge this.inflightData
  // This used to just be a single operation, but creates &#x26; deletes can&#x27;t be
  // composed with regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];

  // The OT type of this document.
  //
  // The document also responds to the api provided by the type
  this.type = null;

  // For debouncing getLatestOps calls
  this._getLatestTimeout = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client" id="apidoc.element.share.db.client">
        function <span class="apidocSignatureSpan">share.</span>db.client
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Livedb(options) {
  // Allow usage as
  //   var myClient = client(options);
  // or
  //   var myClient = new livedb.client(options);
  if (!(this instanceof Livedb)) return new Livedb(options);

  if (!options) throw new Error(&#x27;livedb missing database options&#x27;);

  if (options.redis)
    throw Error(&#x27;If you want to use redis, you need to instantiate the redis driver separately and provide it to livedb&#x27; +
       &#x27; via driver:livedb.redisDriver(db, redis, redisObserver&#x27;);

  // Database which stores the documents.
  this.snapshotDb = options.snapshotDb || options.db || options;

  if (!this.snapshotDb.getSnapshot || !this.snapshotDb.writeSnapshot) {
    throw new Error(&#x27;Missing or invalid snapshot db&#x27;);
  }

  this.driver = options.driver || require(&#x27;./inprocessdriver&#x27;)(options.oplog || options.db || options);

  // This contains any extra databases that can be queried &#x26; notified when documents change
  this.extraDbs = options.extraDbs || {};

  // Statsd client. Either accept a statsd client directly via options.statsd
  // or accept statsd options via options.statsd and create a statsd client
  // from them.
  if (options.sdc) {
    this.sdc = options.sdc;
  } else if (options.statsd) {
    if (!SDC) throw Error(&#x27;statsd not found - `npm install statsd` for statsd support&#x27;);
    this.sdc = new SDC(options.statsd);
    this.closeSdc = true;
  }
  if (this.sdc &#x26;&#x26; !this.driver.sdc) {
    this.driver.sdc = this.sdc;
  }

  // this.onOp = this.onOp.bind(this);
  bulkSubscribe.mixinSnapshotFn(this.snapshotDb);

  // Map from projected collection -&#x3e; {type, fields}
  this.projections = {};

  this.getDirtyDataPre = options.getDirtyDataPre || doNothing;
  this.getDirtyData = options.getDirtyData || doNothing;

  this.suppressCollectionPublish = !!options.suppressCollectionPublish;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver" id="apidoc.element.share.db.inprocessDriver">
        function <span class="apidocSignatureSpan">share.</span>db.inprocessDriver
        <span class="apidocSignatureSpan">(oplog)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InprocDriver(oplog) {
  if (!(this instanceof InprocDriver)) return new InprocDriver(oplog);

  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Emitter for channel messages. Ops are emitted on both the doc&#x27;s CD and its collection name.
  // Listener is called with (op, channel)
  this.subscribers = new EventEmitter();
  // We will be registering a lot of events. Surpress warnings.
  this.subscribers.setMaxListeners(0);

  // Bookkeeping simply so we can
  this.numStreams = 0;
  this.nextStreamId = 0;
  this.streams = {};

  // Map from list name -&#x3e; list of dirty data.
  this.dirtyLists = {};
  // A map from dirty list name -&#x3e; waiting callback
  this.dirtyWaiters = {};

  // Cache of CD -&#x3e; current doc version. This is needed because there&#x27;s a potential race condition
  // where getOps could be missing an operation thats just been processed and as a result we&#x27;ll
  // accept the same op for the same document twice. Data in here should be cleared out periodically
  // (like, 15 seconds after nobody has submitted to the document), but that logic hasn&#x27;t been
  // implemented yet.
  this.versions = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory" id="apidoc.element.share.db.memory">
        function <span class="apidocSignatureSpan">share.</span>db.memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  if (!(this instanceof Memory)) return new Memory();

  // Map from collection name -&#x3e; doc name -&#x3e; snapshot ({v:, type:, data:})
  this.collections = {};

  // Map from collection name -&#x3e; doc name -&#x3e; list of operations. Operations
  // don&#x27;t store their version - instead their version is simply the index in
  // the list.
  this.ops = {};

  this.closed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver" id="apidoc.element.share.db.redisDriver">
        function <span class="apidocSignatureSpan">share.</span>db.redisDriver
        <span class="apidocSignatureSpan">(oplog, client, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisDriver(oplog, client, observer) {
  if (!(this instanceof RedisDriver)) return new RedisDriver(oplog, client, observer);

  // Redis is used for atomic version incrementing, as an operation cache and for pubsub.
  this.redis = client || redisLib.createClient();

  // Persistant oplog.
  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Redis doesn&#x27;t allow the same connection to both listen to channels and do
  // operations. We make an extra redis connection for the streams.
  this.redisObserver = observer;
  if (!this.redisObserver) {
    // We can&#x27;t copy the selected db, but pubsub messages aren&#x27;t namespaced to their db anyway.
    // port and host are stored inside connectionOption object in redis &#x3e;= 0.12. previously they
    // were stored directly on the redis client itself.
    var port = this.redis.connectionOption ? this.redis.connectionOption.port : this.redis.port;
    var host = this.redis.connectionOption ? this.redis.connectionOption.host : this.redis.host;
    this.redisObserver = redisLib.createClient(this.redis.options, port, host);
    if (this.redis.auth_path) this.redisObserver.auth(this.redis.auth_pass);
    this.redisObserverCreated = true;
  }

  var self = this;
  this.redisObserver.on(&#x27;message&#x27;, function(channel, msg) {
    if (self.sdc) self.sdc.increment(&#x27;livedb.redis.message&#x27;);

    var data = JSON.parse(msg);

    var channelStreams = self.streams[channel];
    if (channelStreams) {
      for (var id in channelStreams) {
        channelStreams[id].pushOp(data);
      }
    }
    self.subscribers.emit(channel, channel, data);
  });

  // Emitter for channel messages. Event is the prefixed channel name. Listener is
  // called with (prefixed channel, msg)
  // TODO: This is only being used by the dirty queue now. It could probably
  // be removed and replaced with a simple map that would have less overhead
  this.subscribers = new EventEmitter();
  // Surpress max listener warnings
  this.subscribers.setMaxListeners(0);

  // For keeping track of streams
  this.nextStreamId = 0;
  this.numStreams = 0;
  // Maps channel -&#x3e; id -&#x3e; stream
  this.streams = {};

  // State for tracking subscriptions. We track this.subscribed separately from
  // the streams, since the stream gets added synchronously, and the subscribe
  // isn&#x27;t complete until the callback returns from Redis
  // Maps channel -&#x3e; true
  this.subscribed = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session" id="apidoc.element.share.session">
        function <span class="apidocSignatureSpan">share.</span>session
        <span class="apidocSignatureSpan">(instance, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Session(instance, stream) {
  // The stream passed in should be a nodejs 0.10-style stream.
  this.stream = stream;

  // This is the user agent through which a connecting client acts.  The agent
  // is responsible for making sure client requests are properly authorized,
  // and metadata is kept up to date.
  this.agent = instance.createAgent(stream);
  this.agent.session = this;

  // We need to track which documents are subscribed by the client. This is a
  // map of collection name -&#x3e; {doc name: stream || true || false}
  this.collections = {};

  // Map from query ID -&#x3e; emitter.
  this.queries = {};

  // Subscriptions care about the stream being destroyed. We end up with a
  // listener per subscribed document for the client, which can be a lot.
  stream.setMaxListeners(0);

  // We need to track this manually to make sure we don&#x27;t reply to messages
  // after the stream was closed. There&#x27;s no built-in way to ask a stream
  // whether its actually still open.
  this.closed = false;

  stream.once(&#x27;end&#x27;, this._cleanup.bind(this));

  // Initialize the remote client by sending it its session Id.
  this._send({a:&#x27;init&#x27;, protocol:0, id:this.agent.sessionId});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent" id="apidoc.element.share.useragent">
        function <span class="apidocSignatureSpan">share.</span>useragent
        <span class="apidocSignatureSpan">(instance, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useragent = function (instance, stream) {
  this.instance = instance;
  this.backend = instance.backend;

  this.stream = stream;
  this.sessionId = hat();

  this.connectTime = new Date();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.client" id="apidoc.module.share.client">module share.client</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Connection" id="apidoc.element.share.client.Connection">
        function <span class="apidocSignatureSpan">share.client.</span>Connection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (socket) {
  emitter.EventEmitter.call(this);

  // Map of collection -&#x3e; docName -&#x3e; doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -&#x3e; query object.
  this.queries = {};

  // State of the connection. The correspoding events are emmited when this
  // changes. Available states are:
  // - &#x27;connecting&#x27;   The connection has been established, but we don&#x27;t have our
  //                  client ID yet
  // - &#x27;connected&#x27;    We have connected and recieved our client ID. Ready for data.
  // - &#x27;disconnected&#x27; The connection is closed, but it will reconnect automatically.
  // - &#x27;stopped&#x27;      The connection is closed, and should not reconnect.
  this.state = &#x27;disconnected&#x27;;

  // This is a helper variable the document uses to see whether we&#x27;re currently
  // in a &#x27;live&#x27; state. It is true if we&#x27;re connected, or if you&#x27;re using
  // browserchannel and connecting.
  this.canSend = false;

  // Private variable to support clearing of op retry interval
  this._retryInterval = null;

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  // I&#x27;ll store the most recent 100 messages so when errors occur we can see
  // what happened.
  this.messageBuffer = [];

  this.bindToSocket(socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The client needs a
[websocket](https://developer.mozilla.org/en-US/docs/WebSockets)-like session
object to communicate. You can use a normal websocket if you want:

```javascript
var ws = new WebSocket(&#x27;ws://&#x27; + window.location.host);
var share = new sharejs.<span class="apidocCodeKeywordSpan">Connection</span>(ws);
```

Sharejs also supports the following changes from the spec:

- The socket can reconnect. Simply call `socket.onopen` again when the socket
reconnects and sharejs will reestablish its session state and send any
outstanding user data.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc" id="apidoc.element.share.client.Doc">
        function <span class="apidocSignatureSpan">share.client.</span>Doc
        <span class="apidocSignatureSpan">(connection, collection, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Doc = function (connection, collection, name) {
  emitter.EventEmitter.call(this);

  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;
  this.snapshot = undefined;

  // **** State in document:

  // The action the document tries to perform with the server
  //
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit: send an operation
  this.action = null;

  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don&#x27;t know whats going on.
  //   - Floating (&#x27;floating&#x27;): we have a locally created document that hasn&#x27;t
  //     been created on the server yet)
  //   - Live (&#x27;ready&#x27;) (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we&#x27;re subscribed on the server, or we aren&#x27;t.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server (&#x27;fetch&#x27;), or we don&#x27;t care (false). This is also used when we
  // disconnect &#x26; reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we&#x27;ll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn&#x27;t provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];

  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge this.inflightData
  // This used to just be a single operation, but creates &#x26; deletes can&#x27;t be
  // composed with regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];

  // The OT type of this document.
  //
  // The document also responds to the api provided by the type
  this.type = null;

  // For debouncing getLatestOps calls
  this._getLatestTimeout = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.registerType" id="apidoc.element.share.client.registerType">
        function <span class="apidocSignatureSpan">share.client.</span>registerType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerType = function (type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.ottypes = {};
exports.registerType = function(type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
};

exports.<span class="apidocCodeKeywordSpan">registerType</span>(require(&#x27;ot-json0&#x27;).type);
exports.registerType(require(&#x27;ot-text&#x27;).type);
exports.registerType(require(&#x27;ot-text-tp2&#x27;).type);

// The types register themselves on their respective types.
require(&#x27;./text-api&#x27;);
require(&#x27;./text-tp2-api&#x27;);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.client.Connection" id="apidoc.module.share.client.Connection">module share.client.Connection</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Connection.Connection" id="apidoc.element.share.client.Connection.Connection">
        function <span class="apidocSignatureSpan">share.client.</span>Connection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (socket) {
  emitter.EventEmitter.call(this);

  // Map of collection -&#x3e; docName -&#x3e; doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -&#x3e; query object.
  this.queries = {};

  // State of the connection. The correspoding events are emmited when this
  // changes. Available states are:
  // - &#x27;connecting&#x27;   The connection has been established, but we don&#x27;t have our
  //                  client ID yet
  // - &#x27;connected&#x27;    We have connected and recieved our client ID. Ready for data.
  // - &#x27;disconnected&#x27; The connection is closed, but it will reconnect automatically.
  // - &#x27;stopped&#x27;      The connection is closed, and should not reconnect.
  this.state = &#x27;disconnected&#x27;;

  // This is a helper variable the document uses to see whether we&#x27;re currently
  // in a &#x27;live&#x27; state. It is true if we&#x27;re connected, or if you&#x27;re using
  // browserchannel and connecting.
  this.canSend = false;

  // Private variable to support clearing of op retry interval
  this._retryInterval = null;

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  // I&#x27;ll store the most recent 100 messages so when errors occur we can see
  // what happened.
  this.messageBuffer = [];

  this.bindToSocket(socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The client needs a
[websocket](https://developer.mozilla.org/en-US/docs/WebSockets)-like session
object to communicate. You can use a normal websocket if you want:

```javascript
var ws = new WebSocket(&#x27;ws://&#x27; + window.location.host);
var share = new sharejs.<span class="apidocCodeKeywordSpan">Connection</span>(ws);
```

Sharejs also supports the following changes from the spec:

- The socket can reconnect. Simply call `socket.onopen` again when the socket
reconnects and sharejs will reestablish its session state and send any
outstanding user data.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.client.Connection.prototype" id="apidoc.module.share.client.Connection.prototype">module share.client.Connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._addDoc" id="apidoc.element.share.client.Connection.prototype._addDoc">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_addDoc
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addDoc = function (doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) {
    collectionObject = this.collections[doc.collection] = {};
  }
  if (collectionObject[doc.name] !== doc) {
    collectionObject[doc.name] = doc;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.send({a:&#x27;bs&#x27;, s:this.subscribeData});
}
this.subscribeData = null;
};

Connection.prototype.sendSubscribe = function(doc, version) {
// Ensure the doc is registered so that it receives the reply message
this.<span class="apidocCodeKeywordSpan">_addDoc</span>(doc);
if (this.subscribeData) {
  // Bulk subscribe
  var data = this.subscribeData;
  if (!data[doc.collection]) data[doc.collection] = {};
  data[doc.collection][doc.name] = version || null;
} else {
  // Send single subscribe message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._createQuery" id="apidoc.element.share.client.Connection.prototype._createQuery">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_createQuery
        <span class="apidocSignatureSpan">(type, collection, q, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createQuery = function (type, collection, q, options, callback) {
  if (type !== &#x27;fetch&#x27; &#x26;&#x26; type !== &#x27;sub&#x27;)
    throw new Error(&#x27;Invalid query type: &#x27; + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// results directly into the callback.
//
// The index is specific to the source, but if you&#x27;re using mongodb it&#x27;ll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this.<span class="apidocCodeKeywordSpan">_createQuery</span>(&#x27;fetch&#x27;, index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._destroyDoc" id="apidoc.element.share.client.Connection.prototype._destroyDoc">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_destroyDoc
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroyDoc = function (doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won&#x27;t do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Doc.prototype.destroy = function(callback) {
var doc = this;
this.unsubscribe(function() {
  // Don&#x27;t care if there&#x27;s an error unsubscribing.

  if (doc.hasPending()) {
    doc.once(&#x27;nothing pending&#x27;, function() {
      doc.connection.<span class="apidocCodeKeywordSpan">_destroyDoc</span>(doc);
    });
  } else {
    doc.connection._destroyDoc(doc);
  }
  doc.removeContexts();
  if (callback) callback();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._destroyQuery" id="apidoc.element.share.client.Connection.prototype._destroyQuery">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_destroyQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroyQuery = function (query) {
  delete this.queries[query.id];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend &#x26;&#x26; this.type === &#x27;sub&#x27;) {
    this.connection.send({a:&#x27;qunsub&#x27;, id:this.id});
  }

  this.connection.<span class="apidocCodeKeywordSpan">_destroyQuery</span>(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === &#x27;connecting&#x27;) {
    this._execute();
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._setState" id="apidoc.element.share.client.Connection.prototype._setState">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_setState
        <span class="apidocSignatureSpan">(newState, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setState = function (newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // &#x27;connecting&#x27; from anywhere other than &#x27;disconnected&#x27; and getting to
  // &#x27;connected&#x27; from anywhere other than &#x27;connecting&#x27;.
  if (
    (newState === &#x27;connecting&#x27; &#x26;&#x26; this.state !== &#x27;disconnected&#x27; &#x26;&#x26; this.state !== &#x27;stopped&#x27;) ||
    (newState === &#x27;connected&#x27; &#x26;&#x26; this.state !== &#x27;connecting&#x27;)
  ) {
    throw new Error(&#x22;Cannot transition directly from &#x22; + this.state + &#x22; to &#x22; + newState);
  }

  this.state = newState;
  this.canSend =
    (newState === &#x27;connecting&#x27; &#x26;&#x26; this.socket.canSendWhileConnecting) ||
    (newState === &#x27;connected&#x27;);
  this._setupRetry();

  if (newState === &#x27;disconnected&#x27;) this.reset();

  this.emit(newState, data);

  // Group all subscribes together to help server make more efficient calls
  this.bsStart();
  // Emit the event to all queries
  for (var id in this.queries) {
    var query = this.queries[id];
    query._onConnectionStateChanged(newState, data);
  }
  // Emit the event to all documents
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }
  this.bsEnd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    connection.emit(&#x27;error&#x27;, err, data);
    // We could also restart the connection here, although that might result
    // in infinite reconnection bugs.
  }
}

socket.onopen = function() {
  connection.<span class="apidocCodeKeywordSpan">_setState</span>(&#x27;connecting&#x27;);
};

socket.onerror = function(e) {
  // This isn&#x27;t the same as a regular error, because it will happen normally
  // from time to time. Your connection should probably automatically
  // reconnect anyway, but that should be triggered off onclose not onerror.
  // (onclose happens when onerror gets called anyway).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype._setupRetry" id="apidoc.element.share.client.Connection.prototype._setupRetry">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>_setupRetry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setupRetry = function () {
  if (!this.canSend) {
    clearInterval(this._retryInterval);
    this._retryInterval = null;
    return;
  }
  if (this._retryInterval != null) return;

  var connection = this;
  this._retryInterval = setInterval(function() {
    for (var collectionName in connection.collections) {
      var collection = connection.collections[collectionName];
      for (var docName in collection) {
        collection[docName].retry();
      }
    }
  }, 1000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // TODO: Check that the socket is in the &#x27;connecting&#x27; state.

  this.socket = socket;
  // This logic is replicated in setState - consider calling setState here
  // instead.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? &#x27;connecting&#x27; : &#x27;disconnected&#x27;;
  this.canSend = this.state === &#x27;connecting&#x27; &#x26;&#x26; socket.canSendWhileConnecting;
  this.<span class="apidocCodeKeywordSpan">_setupRetry</span>();

  var connection = this

  socket.onmessage = function(msg) {
var data = msg.data;

// Fall back to supporting old browserchannel 1.x API which implemented the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.addListener" id="apidoc.element.share.client.Connection.prototype.addListener">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
SubDoc.prototype.add = function(path, amount, cb) {
  return normalizeArgs(this, arguments, function(path, amount, cb) {
    return this.context.add(path, amount, cb);
  });
};

SubDoc.prototype.on = function(event, cb) {
  return this.context.<span class="apidocCodeKeywordSpan">addListener</span>(this.path, event, cb);
};

SubDoc.prototype.removeListener = function(l) {
  return this.context.removeListener(l);
};

SubDoc.prototype.getLength = function(path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.bindToSocket" id="apidoc.element.share.client.Connection.prototype.bindToSocket">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bindToSocket
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindToSocket = function (socket) {
  if (this.socket) {
    delete this.socket.onopen
    delete this.socket.onclose
    delete this.socket.onmessage
    delete this.socket.onerror
  }

  // TODO: Check that the socket is in the &#x27;connecting&#x27; state.

  this.socket = socket;
  // This logic is replicated in setState - consider calling setState here
  // instead.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? &#x27;connecting&#x27; : &#x27;disconnected&#x27;;
  this.canSend = this.state === &#x27;connecting&#x27; &#x26;&#x26; socket.canSendWhileConnecting;
  this._setupRetry();

  var connection = this

  socket.onmessage = function(msg) {
    var data = msg.data;

    // Fall back to supporting old browserchannel 1.x API which implemented the
    // websocket API incorrectly. This will be removed at some point
    if (!data) data = msg;

    // Some transports don&#x27;t need parsing.
    if (typeof data === &#x27;string&#x27;) data = JSON.parse(data);

    if (connection.debug) console.log(&#x27;RECV&#x27;, JSON.stringify(data));

    connection.messageBuffer.push({
      t: (new Date()).toTimeString(),
      recv:JSON.stringify(data)
    });
    while (connection.messageBuffer.length &#x3e; 100) {
      connection.messageBuffer.shift();
    }

    try {
      connection.handleMessage(data);
    } catch (err) {
      connection.emit(&#x27;error&#x27;, err, data);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState(&#x27;connecting&#x27;);
  };

  socket.onerror = function(e) {
    // This isn&#x27;t the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit(&#x27;connection error&#x27;, e);
  };

  socket.onclose = function(reason) {
    // reason values:
    //   &#x27;Closed&#x27; - The socket was manually closed by calling socket.close()
    //   &#x27;Stopped by server&#x27; - The server sent the stop message to tell the client not to try connecting
    //   &#x27;Request failed&#x27; - Server didn&#x27;t respond to request (temporary, usually offline)
    //   &#x27;Unknown session ID&#x27; - Server session for client is missing (temporary, will immediately reestablish)
    connection._setState(&#x27;disconnected&#x27;, reason);
    if (reason === &#x27;Closed&#x27; || reason === &#x27;Stopped by server&#x27;) {
      connection._setState(&#x27;stopped&#x27;, reason);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 this.debug = false;

 // I&#x27;ll store the most recent 100 messages so when errors occur we can see
 // what happened.
 this.messageBuffer = [];

 this.<span class="apidocCodeKeywordSpan">bindToSocket</span>(socket);
}
emitter.mixin(Connection);


/**
* Use socket to communicate with server
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.bsEnd" id="apidoc.element.share.client.Connection.prototype.bsEnd">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bsEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bsEnd = function () {
  // Only send bulk subscribe if not empty
  if (hasKeys(this.subscribeData)) {
    this.send({a:&#x27;bs&#x27;, s:this.subscribeData});
  }
  this.subscribeData = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Emit the event to all documents
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }
  this.<span class="apidocCodeKeywordSpan">bsEnd</span>();
};

Connection.prototype.bsStart = function() {
  this.subscribeData = this.subscribeData || {};
};

Connection.prototype.bsEnd = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.bsStart" id="apidoc.element.share.client.Connection.prototype.bsStart">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>bsStart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bsStart = function () {
  this.subscribeData = this.subscribeData || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._setupRetry();

if (newState === &#x27;disconnected&#x27;) this.reset();

this.emit(newState, data);

// Group all subscribes together to help server make more efficient calls
this.<span class="apidocCodeKeywordSpan">bsStart</span>();
// Emit the event to all queries
for (var id in this.queries) {
  var query = this.queries[id];
  query._onConnectionStateChanged(newState, data);
}
// Emit the event to all documents
for (var c in this.collections) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.createFetchQuery" id="apidoc.element.share.client.Connection.prototype.createFetchQuery">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>createFetchQuery
        <span class="apidocSignatureSpan">(index, q, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFetchQuery = function (index, q, options, callback) {
  return this._createQuery(&#x27;fetch&#x27;, index, q, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.createSubscribeQuery" id="apidoc.element.share.client.Connection.prototype.createSubscribeQuery">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>createSubscribeQuery
        <span class="apidocSignatureSpan">(index, q, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSubscribeQuery = function (index, q, options, callback) {
  return this._createQuery(&#x27;sub&#x27;, index, q, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//var doc = sjs.get(&#x27;users&#x27;, &#x27;seph&#x27;);
doc.create(&#x27;text&#x27;, function(e) { if (e) console.error(&#x27;x&#x27;, e); });
doc.createContext().insert(&#x27;hi there&#x27;);
console.log(doc);

/*
setTimeout(function() {
  var q = sjs.<span class="apidocCodeKeywordSpan">createSubscribeQuery</span>(&#x27;users&#x27;, {&#x22;data.x&#x22;:5}, {autoFetch
:true});
  setTimeout(function() {
    q.destroy();
  }, 0);


}, 1000);
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.disconnect" id="apidoc.element.share.client.Connection.prototype.disconnect">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  this.socket.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  assert @connection.messageBuffer.length == 1


  describe &#x27;#disconnect&#x27;, -&#x3e;

it &#x27;calls socket.close()&#x27;, -&#x3e;
  close = sinon.spy socket, &#x27;close&#x27;
  @connection.<span class="apidocCodeKeywordSpan">disconnect</span>()
  sinon.assert.calledOnce close
  close.reset()

it &#x27;emits disconnected&#x27;, -&#x3e;
  emit = sinon.spy @connection, &#x27;emit&#x27;
  @connection.disconnect()
  sinon.assert.calledWith emit, &#x27;disconnected&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.emit" id="apidoc.element.share.client.Connection.prototype.emit">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

client.on(&#x27;message&#x27;, function(data) {
  stream.push(data);
});

client.on(&#x27;close&#x27;, function(reason) {
  stream.push(null);
  stream.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;close&#x27;);
});

stream.on(&#x27;end&#x27;, function() {
  client.close();
});

// Give the stream to sharejs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.eventNames" id="apidoc.element.share.client.Connection.prototype.eventNames">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.get" id="apidoc.element.share.client.Connection.prototype.get">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>get
        <span class="apidocSignatureSpan">(collection, name, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (collection, name, data) {
  var collectionObject = this.collections[collection];
  if (!collectionObject)
    collectionObject = this.collections[collection] = {};

  var doc = collectionObject[name];
  if (!doc) {
    doc = collectionObject[name] = new Doc(this, collection, name);
    this.emit(&#x27;doc&#x27;, doc);
  }

  // Even if the document isn&#x27;t new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data &#x26;&#x26; data.data !== undefined &#x26;&#x26; !doc.state) {
    doc.ingestData(data);
  }

  return doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The client exposes 2 classes you care about:

- The **Connection** class wraps a socket and handles the communication to the
sharejs server. You use the connection instance to create document references
in the client.
- All actual data you edit will be wrapped by the **Doc** class. The document
class stores an in-memory copy of the document data with your local edits
applied.  Create a document instance by calling `connection.<span class="apidocCodeKeywordSpan">get</span>(&#x27;collection&#x27
;, &#x27;docname&#x27;)`.

&#x3e; ShareJS also allows you to make queries to your database. Live-bound queries
will return a **Query** object. These are not currently documented.

To get started, you first need to create a connection:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.getExisting" id="apidoc.element.share.client.Connection.prototype.getExisting">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getExisting
        <span class="apidocSignatureSpan">(collection, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExisting = function (collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    break;

  default:
    // Document message. Pull out the referenced document and forward the
    // message.
    var doc = this.<span class="apidocCodeKeywordSpan">getExisting</span>(msg.c, msg.d);
    if (doc) doc._onMessage(msg);
}
};


Connection.prototype.reset = function() {
this.id = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.getMaxListeners" id="apidoc.element.share.client.Connection.prototype.getMaxListeners">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.getOrCreate" id="apidoc.element.share.client.Connection.prototype.getOrCreate">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>getOrCreate
        <span class="apidocSignatureSpan">(collection, name, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOrCreate = function (collection, name, data) {
  console.trace(&#x27;getOrCreate is deprecated. Use get() instead&#x27;);
  return this.get(collection, name, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;script src=&#x22;share.js&#x22;&#x3e;&#x3c;/script&#x3e;
&#x3c;script&#x3e;

var s = new BCSocket(null, {reconnect: true});

var sjs = new window.sharejs.Connection(s);

var doc = sjs.<span class="apidocCodeKeywordSpan">getOrCreate</span>(&#x27;json_test&#x27;, &#x27;test_doc_1&#x27;);

console.log(doc);

doc.subscribe();

doc.whenReady(function () {
console.log(doc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.handleMessage" id="apidoc.element.share.client.Connection.prototype.handleMessage">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>handleMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleMessage = function (msg) {
  // Switch on the message action. Most messages are for documents and are
  // handled in the doc class.
  switch (msg.a) {
    case &#x27;init&#x27;:
      // Client initialization packet. This bundle of joy contains our client
      // ID.
      if (msg.protocol !== 0) throw new Error(&#x27;Invalid protocol version&#x27;);
      if (typeof msg.id != &#x27;string&#x27;) throw new Error(&#x27;Invalid client id&#x27;);

      this.id = msg.id;
      this._setState(&#x27;connected&#x27;);
      break;

    case &#x27;qfetch&#x27;:
    case &#x27;qsub&#x27;:
    case &#x27;q&#x27;:
    case &#x27;qunsub&#x27;:
      // Query message. Pass this to the appropriate query object.
      var query = this.queries[msg.id];
      if (query) query._onMessage(msg);
      break;

    case &#x27;bs&#x27;:
      // Bulk subscribe response. The responses for each document are contained within.
      var result = msg.s;
      for (var cName in result) {
        for (var docName in result[cName]) {
          var doc = this.get(cName, docName);
          if (!doc) {
            console.warn(&#x27;Message for unknown doc. Ignoring.&#x27;, msg);
            break;
          }

          var msg = result[cName][docName];
          if (typeof msg === &#x27;object&#x27;) {
            doc._handleSubscribe(msg.error, msg);
          } else {
            // The msg will be true if we simply resubscribed.
            doc._handleSubscribe(null, null);
          }
        }
      }
      break;

    default:
      // Document message. Pull out the referenced document and forward the
      // message.
      var doc = this.getExisting(msg.c, msg.d);
      if (doc) doc._onMessage(msg);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    recv:JSON.stringify(data)
  });
  while (connection.messageBuffer.length &#x3e; 100) {
    connection.messageBuffer.shift();
  }

  try {
    connection.<span class="apidocCodeKeywordSpan">handleMessage</span>(data);
  } catch (err) {
    connection.emit(&#x27;error&#x27;, err, data);
    // We could also restart the connection here, although that might result
    // in infinite reconnection bugs.
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.listenerCount" id="apidoc.element.share.client.Connection.prototype.listenerCount">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.listeners" id="apidoc.element.share.client.Connection.prototype.listeners">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.on" id="apidoc.element.share.client.Connection.prototype.on">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
stream._write = function(chunk, encoding, callback) {
  if (client.state !== &#x27;closed&#x27;) {
    client.send(chunk);
  }
  callback();
};

client.<span class="apidocCodeKeywordSpan">on</span>(&#x27;message&#x27;, function(data) {
  stream.push(data);
});

client.on(&#x27;close&#x27;, function(reason) {
  stream.push(null);
  stream.emit(&#x27;close&#x27;);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.once" id="apidoc.element.share.client.Connection.prototype.once">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
// Don&#x27;t care if there&#x27;s an error unsubscribing.

if (doc.hasPending()) {
  doc.<span class="apidocCodeKeywordSpan">once</span>(&#x27;nothing pending&#x27;, function() {
    doc.connection._destroyDoc(doc);
  });
} else {
  doc.connection._destroyDoc(doc);
}
doc.removeContexts();
if (callback) callback();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.prependListener" id="apidoc.element.share.client.Connection.prototype.prependListener">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.prependOnceListener" id="apidoc.element.share.client.Connection.prototype.prependOnceListener">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.removeAllListeners" id="apidoc.element.share.client.Connection.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
}

// emit removeListener for all listeners on all events
if (arguments.length === 0) {
  for (key in this._events) {
    if (key === &#x27;removeListener&#x27;) continue;
    this.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(key);
  }
  this.removeAllListeners(&#x27;removeListener&#x27;);
  this._events = {};
  return this;
}

listeners = this._events[type];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.removeListener" id="apidoc.element.share.client.Connection.prototype.removeListener">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
EventEmitter.prototype.once = function(type, listener) {
if (!isFunction(listener))
  throw TypeError(&#x27;listener must be a function&#x27;);

var fired = false;

function g() {
  this.<span class="apidocCodeKeywordSpan">removeListener</span>(type, g);

  if (!fired) {
    fired = true;
    listener.apply(this, arguments);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.reset" id="apidoc.element.share.client.Connection.prototype.reset">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  this.id = null;
  this.seq = 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// browserchannel and connecting.
this.canSend = false;

// Private variable to support clearing of op retry interval
this._retryInterval = null;

// Reset some more state variables.
this.<span class="apidocCodeKeywordSpan">reset</span>();

this.debug = false;

// I&#x27;ll store the most recent 100 messages so when errors occur we can see
// what happened.
this.messageBuffer = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.send" id="apidoc.element.share.client.Connection.prototype.send">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>send
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (msg) {
  if (this.debug) console.log(&#x22;SEND&#x22;, JSON.stringify(msg));

  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length &#x3e; 100) {
    this.messageBuffer.shift();
  }

  if (!this.socket.canSendJSON) {
    msg = JSON.stringify(msg);
  }
  this.socket.send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

app.use(browserChannel({webserver: webserver}, function(client) {
var stream = new Duplex({objectMode: true});

stream._read = function() {};
stream._write = function(chunk, encoding, callback) {
  if (client.state !== &#x27;closed&#x27;) {
    client.<span class="apidocCodeKeywordSpan">send</span>(chunk);
  }
  callback();
};

client.on(&#x27;message&#x27;, function(data) {
  stream.push(data);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.sendFetch" id="apidoc.element.share.client.Connection.prototype.sendFetch">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendFetch
        <span class="apidocSignatureSpan">(doc, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFetch = function (doc, version) {
  // Ensure the doc is registered so that it receives the reply message
  this._addDoc(doc);
  var msg = {a: &#x27;fetch&#x27;, c: doc.collection, d: doc.name};
  if (version != null) msg.v = version;
  this.send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var doc = this;
var debounced = false;
if (doc._getLatestTimeout) {
  debounced = true;
} else {
  // Send a fetch command, which will get us the missing ops to catch back up
  // or the full doc if our version is currently null
  doc.connection.<span class="apidocCodeKeywordSpan">sendFetch</span>(doc, doc.version);
}
// Debounce calls, since we are likely to get multiple future operations
// in a rapid sequence
clearTimeout(doc._getLatestTimeout);
doc._getLatestTimeout = setTimeout(function() {
  doc._getLatestTimeout = null;
  // Send another fetch at the end of the final timeout interval if we were
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.sendOp" id="apidoc.element.share.client.Connection.prototype.sendOp">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendOp
        <span class="apidocSignatureSpan">(doc, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendOp = function (doc, data) {
  // Ensure the doc is registered so that it receives the reply message
  this._addDoc(doc);
  var msg = {
    a: &#x27;op&#x27;,
    c: doc.collection,
    d: doc.name,
    v: doc.version,
    src: data.src,
    seq: data.seq
  };
  if (data.op) msg.op = data.op;
  if (data.create) msg.create = data.create;
  if (data.del) msg.del = data.del;
  this.send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // on the client to match acknowledgement of an op back to the inflightData.
  // Note that the src could be different from this.connection.id after a
  // reconnect, since an op may still be pending after the reconnection and
  // this.connection.id will change. In case an op is sent multiple times, we
  // also need to be careful not to override the original seq value.
  if (data.seq == null) data.seq = this.connection.seq++;

  this.connection.<span class="apidocCodeKeywordSpan">sendOp</span>(this, data);

  // src isn&#x27;t needed on the first try, since the server session will have the
  // same id, but it must be set on the inflightData in case it is sent again
  // after a reconnect and the connection&#x27;s id has changed by then
  if (data.src == null) data.src = src;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.sendSubscribe" id="apidoc.element.share.client.Connection.prototype.sendSubscribe">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendSubscribe
        <span class="apidocSignatureSpan">(doc, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendSubscribe = function (doc, version) {
  // Ensure the doc is registered so that it receives the reply message
  this._addDoc(doc);
  if (this.subscribeData) {
    // Bulk subscribe
    var data = this.subscribeData;
    if (!data[doc.collection]) data[doc.collection] = {};
    data[doc.collection][doc.name] = version || null;
  } else {
    // Send single subscribe message
    var msg = {a: &#x27;sub&#x27;, c: doc.collection, d: doc.name};
    if (version != null) msg.v = version;
    this.send(msg);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  } else if (!this.subscribed &#x26;&#x26; this.wantSubscribe === &#x27;fetch&#x27;) {
    this.action = &#x27;fetch&#x27;;
    this.connection.sendFetch(this, version);

  } else if (!this.subscribed &#x26;&#x26; this.wantSubscribe) {
    this.action = &#x27;subscribe&#x27;;
    this.connection.<span class="apidocCodeKeywordSpan">sendSubscribe</span>(this, version);
  }
};


// ****** Subscribing, unsubscribing and fetching

// Value is true, false or &#x27;fetch&#x27;.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.sendUnsubscribe" id="apidoc.element.share.client.Connection.prototype.sendUnsubscribe">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>sendUnsubscribe
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendUnsubscribe = function (doc) {
  // Ensure the doc is registered so that it receives the reply message
  this._addDoc(doc);
  var msg = {a: &#x27;unsub&#x27;, c: doc.collection, d: doc.name};
  this.send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Ignore if an action is already in process
if (this.action) return;
// Once all ops are sent, perform subscriptions and fetches
var version = (this.state === &#x27;ready&#x27;) ? this.version : null;

if (this.subscribed &#x26;&#x26; !this.wantSubscribe) {
  this.action = &#x27;unsubscribe&#x27;;
  this.connection.<span class="apidocCodeKeywordSpan">sendUnsubscribe</span>(this);

} else if (!this.subscribed &#x26;&#x26; this.wantSubscribe === &#x27;fetch&#x27;) {
  this.action = &#x27;fetch&#x27;;
  this.connection.sendFetch(this, version);

} else if (!this.subscribed &#x26;&#x26; this.wantSubscribe) {
  this.action = &#x27;subscribe&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Connection.prototype.setMaxListeners" id="apidoc.element.share.client.Connection.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">share.client.Connection.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    m = EventEmitter.defaultMaxListeners;
  }

  if (m &#x26;&#x26; m &#x3e; 0 &#x26;&#x26; this._events[type].length &#x3e; m) {
    this._events[type].warned = true;
    console.error(&#x27;(node) warning: possible EventEmitter memory &#x27; +
                  &#x27;leak detected. %d listeners added. &#x27; +
                  &#x27;Use emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>() to increase limit.&#x27;,
                  this._events[type].length);
    if (typeof console.trace === &#x27;function&#x27;) {
      // not supported in IE 10
      console.trace();
    }
  }
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.client.Doc" id="apidoc.module.share.client.Doc">module share.client.Doc</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Doc.Doc" id="apidoc.element.share.client.Doc.Doc">
        function <span class="apidocSignatureSpan">share.client.</span>Doc
        <span class="apidocSignatureSpan">(connection, collection, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Doc = function (connection, collection, name) {
  emitter.EventEmitter.call(this);

  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;
  this.snapshot = undefined;

  // **** State in document:

  // The action the document tries to perform with the server
  //
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit: send an operation
  this.action = null;

  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don&#x27;t know whats going on.
  //   - Floating (&#x27;floating&#x27;): we have a locally created document that hasn&#x27;t
  //     been created on the server yet)
  //   - Live (&#x27;ready&#x27;) (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we&#x27;re subscribed on the server, or we aren&#x27;t.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server (&#x27;fetch&#x27;), or we don&#x27;t care (false). This is also used when we
  // disconnect &#x26; reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we&#x27;ll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn&#x27;t provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];

  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge this.inflightData
  // This used to just be a single operation, but creates &#x26; deletes can&#x27;t be
  // composed with regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];

  // The OT type of this document.
  //
  // The document also responds to the api provided by the type
  this.type = null;

  // For debouncing getLatestOps calls
  this._getLatestTimeout = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.client.Doc.prototype" id="apidoc.module.share.client.Doc.prototype">module share.client.Doc.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._clearAction" id="apidoc.element.share.client.Doc.prototype._clearAction">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_clearAction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_clearAction = function () {
  this.action = null;
  this.flush();
  this._emitNothingPending();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.emit(&#x27;error&#x27;, err);
  // There&#x27;s probably a reason we couldn&#x27;t subscribe. Don&#x27;t retry.
  this._setWantSubscribe(false, null, err);
  return;
}
if (data) this.ingestData(data);
this.subscribed = true;
this.<span class="apidocCodeKeywordSpan">_clearAction</span>();
this.emit(&#x27;subscribe&#x27;);
this._finishSub();
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
if (!(msg.c === this.collection &#x26;&#x26; msg.d === this.name)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._clearInflightOp" id="apidoc.element.share.client.Doc.prototype._clearInflightOp">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_clearInflightOp
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_clearInflightOp = function (error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i &#x3c; callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this.flush();
  this._emitNothingPending();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// subscribed)
if (msg.error &#x26;&#x26; msg.error !== &#x27;Op already submitted&#x27;) {
  // The server has rejected an op from the client for an unexpected reason.
  // We&#x27;ll send the error message to the user and try to roll back the change.
  if (this.inflightData) {
    console.warn(&#x27;Operation was rejected (&#x27; + msg.error + &#x27;). Trying to rollback change locally.&#x27;);
    this._tryRollback(this.inflightData);
    this.<span class="apidocCodeKeywordSpan">_clearInflightOp</span>(msg.error);
  } else {
    // I managed to get into this state once. I&#x27;m not sure how it happened.
    // The op was maybe double-acknowledged?
    console.warn(&#x27;Second acknowledgement message (error) received&#x27;, msg, this);
  }
}
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._emitNothingPending" id="apidoc.element.share.client.Doc.prototype._emitNothingPending">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_emitNothingPending
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_emitNothingPending = function () {
  if (this.hasPending()) return;
  this.emit(&#x27;nothing pending&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._clearAction();
  }
};

Doc.prototype._clearAction = function() {
  this.action = null;
  this.flush();
  this.<span class="apidocCodeKeywordSpan">_emitNothingPending</span>();
};

// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we&#x27;re not currently connected, this method does nothing.
Doc.prototype.flush = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._finishSub" id="apidoc.element.share.client.Doc.prototype._finishSub">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_finishSub
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finishSub = function (err) {
  if (!this._subscribeCallbacks.length) return;
  for (var i = 0; i &#x3c; this._subscribeCallbacks.length; i++) {
    this._subscribeCallbacks[i](err);
  }
  this._subscribeCallbacks.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._setWantSubscribe(false, null, err);
  return;
}
if (data) this.ingestData(data);
this.subscribed = true;
this._clearAction();
this.emit(&#x27;subscribe&#x27;);
this.<span class="apidocCodeKeywordSpan">_finishSub</span>();
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
if (!(msg.c === this.collection &#x26;&#x26; msg.d === this.name)) {
  // This should never happen - its a sanity check for bugs in the connection code.
  var err = &#x27;Got message for wrong document.&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._getLatestOps" id="apidoc.element.share.client.Doc.prototype._getLatestOps">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_getLatestOps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getLatestOps = function () {
  var doc = this;
  var debounced = false;
  if (doc._getLatestTimeout) {
    debounced = true;
  } else {
    // Send a fetch command, which will get us the missing ops to catch back up
    // or the full doc if our version is currently null
    doc.connection.sendFetch(doc, doc.version);
  }
  // Debounce calls, since we are likely to get multiple future operations
  // in a rapid sequence
  clearTimeout(doc._getLatestTimeout);
  doc._getLatestTimeout = setTimeout(function() {
    doc._getLatestTimeout = null;
    // Send another fetch at the end of the final timeout interval if we were
    // debounced to make sure we didn&#x27;t miss anything
    if (debounced) {
      doc.connection.sendFetch(doc, doc.version);
    }
  }, 5000);
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.version == null || msg.v &#x3e; this.version) {
  // This will happen in normal operation if we become subscribed to a
  // new document via a query. It can also happen if we get an op for
  // a future version beyond the version we are expecting next. This
  // could happen if the server doesn&#x27;t publish an op for whatever reason
  // or because of a race condition. In any case, we can send a fetch
  // command to catch back up.
  this.<span class="apidocCodeKeywordSpan">_getLatestOps</span>();
  break;
}

if (msg.v &#x3c; this.version) {
  // This will happen naturally in the following (or similar) cases:
  //
  // Client is not subscribed to document.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._handleSubscribe" id="apidoc.element.share.client.Doc.prototype._handleSubscribe">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_handleSubscribe
        <span class="apidocSignatureSpan">(err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleSubscribe = function (err, data) {
  if (err &#x26;&#x26; err !== &#x27;Already subscribed&#x27;) {
    console.error(&#x27;Could not subscribe:&#x27;, err, this.collection, this.name);
    this.emit(&#x27;error&#x27;, err);
    // There&#x27;s probably a reason we couldn&#x27;t subscribe. Don&#x27;t retry.
    this._setWantSubscribe(false, null, err);
    return;
  }
  if (data) this.ingestData(data);
  this.subscribed = true;
  this._clearAction();
  this.emit(&#x27;subscribe&#x27;);
  this._finishSub();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!doc) {
      console.warn(&#x27;Message for unknown doc. Ignoring.&#x27;, msg);
      break;
    }

    var msg = result[cName][docName];
    if (typeof msg === &#x27;object&#x27;) {
      doc.<span class="apidocCodeKeywordSpan">_handleSubscribe</span>(msg.error, msg);
    } else {
      // The msg will be true if we simply resubscribed.
      doc._handleSubscribe(null, null);
    }
  }
}
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._onConnectionStateChanged" id="apidoc.element.share.client.Doc.prototype._onConnectionStateChanged">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_onConnectionStateChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onConnectionStateChanged = function () {
  if (this.connection.canSend) {
    this.flush();
  } else {
    this.subscribed = false;
    this._clearAction();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.emit(newState, data);

// Group all subscribes together to help server make more efficient calls
this.bsStart();
// Emit the event to all queries
for (var id in this.queries) {
  var query = this.queries[id];
  query.<span class="apidocCodeKeywordSpan">_onConnectionStateChanged</span>(newState, data);
}
// Emit the event to all documents
for (var c in this.collections) {
  var collection = this.collections[c];
  for (var docName in collection) {
    collection[docName]._onConnectionStateChanged(newState, data);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._onMessage" id="apidoc.element.share.client.Doc.prototype._onMessage">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_onMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMessage = function (msg) {
  if (!(msg.c === this.collection &#x26;&#x26; msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    var err = &#x27;Got message for wrong document.&#x27;;
    console.error(err, this.collection, this.name, msg);
    throw new Error(err);
  }

  // msg.a = the action.
  switch (msg.a) {
    case &#x27;fetch&#x27;:
      // We&#x27;re done fetching. This message has no other information.
      if (msg.data) this.ingestData(msg.data);
      if (this.wantSubscribe === &#x27;fetch&#x27;) this.wantSubscribe = false;
      this._clearAction();
      this._finishSub(msg.error);
      break;

    case &#x27;sub&#x27;:
      // Subscribe reply.
      this._handleSubscribe(msg.error, msg.data);
      break;

    case &#x27;unsub&#x27;:
      // Unsubscribe reply
      this.subscribed = false;
      this.emit(&#x27;unsubscribe&#x27;);

      this._clearAction();
      this._finishSub(msg.error);
      break;

    case &#x27;ack&#x27;:
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren&#x27;t
      // subscribed)
      if (msg.error &#x26;&#x26; msg.error !== &#x27;Op already submitted&#x27;) {
        // The server has rejected an op from the client for an unexpected reason.
        // We&#x27;ll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn(&#x27;Operation was rejected (&#x27; + msg.error + &#x27;). Trying to rollback change locally.&#x27;);
          this._tryRollback(this.inflightData);
          this._clearInflightOp(msg.error);
        } else {
          // I managed to get into this state once. I&#x27;m not sure how it happened.
          // The op was maybe double-acknowledged?
          console.warn(&#x27;Second acknowledgement message (error) received&#x27;, msg, this);
        }
      }
      break;

    case &#x27;op&#x27;:
      if (this.inflightData &#x26;&#x26;
          msg.src === this.inflightData.src &#x26;&#x26;
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (this.version == null || msg.v &#x3e; this.version) {
        // This will happen in normal operation if we become subscribed to a
        // new document via a query. It can also happen if we get an op for
        // a future version beyond the version we are expecting next. This
        // could happen if the server doesn&#x27;t publish an op for whatever reason
        // or because of a race condition. In any case, we can send a fetch
        // command to catch back up.
        this._getLatestOps();
        break;
      }

      if (msg.v &#x3c; this.version) {
        // This will happen naturally in the following (or similar) cases:
        //
        // Client is not subscribed to document.
        // -&#x3e; client submits an operation (v=10)
        // -&#x3e; client subscribes to a query which matches this document. Says we
        //    have v=10 of the doc.
        //
        // &#x3c;- server acknowledges the operation (v=11). Server acknowledges the
        //    operation because the doc isn&#x27;t subscribed
        // &#x3c;- server processes the query, which says the client only has v=10.
        //    Server subscribes at v=10 not v=11, so we get another copy of the
        //    v=10 operation.
        //
        // In this case, we can safely ignore the old (duplicate) operation.
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i &#x3c; this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      break;

    case &#x27;meta&#x27;:
      console.warn(&#x27;Unhandled meta op:&#x27;, msg);
      break;

    default:
      console.warn(&#x27;Unhandled document message:&#x27;, msg);
      break;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case &#x27;qfetch&#x27;:
case &#x27;qsub&#x27;:
case &#x27;q&#x27;:
case &#x27;qunsub&#x27;:
  // Query message. Pass this to the appropriate query object.
  var query = this.queries[msg.id];
  if (query) query.<span class="apidocCodeKeywordSpan">_onMessage</span>(msg);
  break;

case &#x27;bs&#x27;:
  // Bulk subscribe response. The responses for each document are contained within.
  var result = msg.s;
  for (var cName in result) {
    for (var docName in result[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._opAcknowledged" id="apidoc.element.share.client.Doc.prototype._opAcknowledged">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_opAcknowledged
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_opAcknowledged = function (msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error(&#x27;opAcknowledged called from a null state. This should never happen. &#x27; + this.collection + &#x27; &#x27; + this.name);
  } else if (this.state === &#x27;floating&#x27;) {
    if (!this.inflightData.create) throw new Error(&#x27;Cannot acknowledge an op. &#x27; + this.collection + &#x27; &#x27; + this.name);

    // Our create has been acknowledged. This is the same as ingesting some data.
    this.version = msg.v;
    this.state = &#x27;ready&#x27;;
    var _this = this;
    setTimeout(function() { _this.emit(&#x27;ready&#x27;); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version) {
      throw new Error(&#x27;Invalid version from server. This can happen when you submit ops in a submitOp callback. Expected: &#x27; + this
.version + &#x27; Message version: &#x27; + msg.v + &#x27; &#x27; + this.collection + &#x27; &#x27; + this.name);
    }
  }

  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
break;

    case &#x27;op&#x27;:
if (this.inflightData &#x26;&#x26;
    msg.src === this.inflightData.src &#x26;&#x26;
    msg.seq === this.inflightData.seq) {
  // This one is mine. Accept it as acknowledged.
  this.<span class="apidocCodeKeywordSpan">_opAcknowledged</span>(msg);
  break;
}

if (this.version == null || msg.v &#x3e; this.version) {
  // This will happen in normal operation if we become subscribed to a
  // new document via a query. It can also happen if we get an op for
  // a future version beyond the version we are expecting next. This
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._otApply" id="apidoc.element.share.client.Doc.prototype._otApply">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_otApply
        <span class="apidocSignatureSpan">(opData, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_otApply = function (opData, context) {
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once(&#x27;unlock&#x27;, function() {
      this.emit(&#x27;create&#x27;, context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once(&#x27;unlock&#x27;, function() {
      this.emit(&#x27;del&#x27;, context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error(&#x27;Document does not exist. &#x27; + this.collection + &#x27; &#x27; + this.name);

    var type = this.type;

    var op = opData.op;

    // The context needs to be told we&#x27;re about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i &#x3c; this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context &#x26;&#x26; c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit(&#x27;before op&#x27;, op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental &#x26;&#x26; type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit(&#x27;op&#x27;, o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit(&#x27;op&#x27;, op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.


  this.locked = false;
  this.emit(&#x27;unlock&#x27;);

  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    // NOTE Handle this with events?
    for (var i = 0; i &#x3c; contexts.length; i++) {
      var c = contexts[i];
      if (c != context &#x26;&#x26; c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i &#x3c; contexts.length; i++) {
      if (contexts[i].shouldBeRemoved) contexts.splice(i--, 1);
    }

    return this.emit(&#x27;after op&#x27;, opData.op, context);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.inflightData) xf(this.inflightData, msg);

  for (var i = 0; i &#x3c; this.pendingData.length; i++) {
    xf(this.pendingData[i], msg);
  }

  this.version++;
  this.<span class="apidocCodeKeywordSpan">_otApply</span>(msg, false);
  break;

case &#x27;meta&#x27;:
  console.warn(&#x27;Unhandled meta op:&#x27;, msg);
  break;

default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._sendOpData" id="apidoc.element.share.client.Doc.prototype._sendOpData">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_sendOpData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendOpData = function () {
  // Wait until we have a src id from the server
  var src = this.connection.id;
  if (!src) return;

  // When there is no inflightData, send the first item in pendingData. If
  // there is inflightData, try sending it again
  if (!this.inflightData) {
    // Send first pending op
    this.inflightData = this.pendingData.shift();
  }
  var data = this.inflightData;
  if (!data) {
    throw new Error(&#x27;no data to send on call to _sendOpData&#x27;);
  }

  // Track data for retrying ops
  data.sentAt = Date.now();
  data.retries = (data.retries == null) ? 0 : data.retries + 1;

  // The src + seq number is a unique ID representing this operation. This tuple
  // is used on the server to detect when ops have been sent multiple times and
  // on the client to match acknowledgement of an op back to the inflightData.
  // Note that the src could be different from this.connection.id after a
  // reconnect, since an op may still be pending after the reconnection and
  // this.connection.id will change. In case an op is sent multiple times, we
  // also need to be careful not to override the original seq value.
  if (data.seq == null) data.seq = this.connection.seq++;

  this.connection.sendOp(this, data);

  // src isn&#x27;t needed on the first try, since the server session will have the
  // same id, but it must be set on the inflightData in case it is sent again
  // after a reconnect and the connection&#x27;s id has changed by then
  if (data.src == null) data.src = src;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    callbacks[i](opData.error);
  }
  this.pendingData.shift();
}

// Send first pending op unless paused
if (!this.paused &#x26;&#x26; this.pendingData.length) {
  this.<span class="apidocCodeKeywordSpan">_sendOpData</span>();
  return;
}

// Ignore if an action is already in process
if (this.action) return;
// Once all ops are sent, perform subscriptions and fetches
var version = (this.state === &#x27;ready&#x27;) ? this.version : null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._setType" id="apidoc.element.share.client.Doc.prototype._setType">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_setType
        <span class="apidocSignatureSpan">(newType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setType = function (newType) {
  if (typeof newType === &#x27;string&#x27;) {
    if (!types[newType]) throw new Error(&#x22;Missing type &#x22; + newType + &#x27; &#x27; + this.collection + &#x27; &#x27; + this.name);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
    this.snapshot = undefined;
  } else if (newType.api) {
    // Register the new type&#x27;s API.
    this.provides = newType.api.provides;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }

  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data;
  this.<span class="apidocCodeKeywordSpan">_setType</span>(data.type);

  this.state = &#x27;ready&#x27;;
  this.emit(&#x27;ready&#x27;);
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._setWantSubscribe" id="apidoc.element.share.client.Doc.prototype._setWantSubscribe">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_setWantSubscribe
        <span class="apidocSignatureSpan">(value, callback, err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setWantSubscribe = function (value, callback, err) {
  if (this.subscribed === this.wantSubscribe &#x26;&#x26;
      (this.subscribed === value || value === &#x27;fetch&#x27; &#x26;&#x26; this.subscribed)) {
    if (callback) callback(err);
    return;
  }

  // If we want to subscribe, don&#x27;t weaken it to a fetch.
  if (value !== &#x27;fetch&#x27; || this.wantSubscribe !== true) {
    this.wantSubscribe = value;
  }

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
Doc.prototype._handleSubscribe = function(err, data) {
if (err &#x26;&#x26; err !== &#x27;Already subscribed&#x27;) {
  console.error(&#x27;Could not subscribe:&#x27;, err, this.collection, this.name);
  this.emit(&#x27;error&#x27;, err);
  // There&#x27;s probably a reason we couldn&#x27;t subscribe. Don&#x27;t retry.
  this.<span class="apidocCodeKeywordSpan">_setWantSubscribe</span>(false, null, err);
  return;
}
if (data) this.ingestData(data);
this.subscribed = true;
this._clearAction();
this.emit(&#x27;subscribe&#x27;);
this._finishSub();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._submitOpData" id="apidoc.element.share.client.Doc.prototype._submitOpData">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_submitOpData
        <span class="apidocSignatureSpan">(opData, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_submitOpData = function (opData, context, callback) {
  if (typeof context === &#x27;function&#x27;) {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  if (this.locked) {
    var err = &#x22;Cannot call submitOp from inside an &#x27;op&#x27; event handler. &#x22; + this.collection + &#x27; &#x27; + this.name;
    if (callback) return callback(err);
    throw new Error(err);
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).
  if (opData.op) {
    if (!this.type) {
      var err = &#x27;Document has not been created&#x27;;
      if (callback) return callback(err);
      throw new Error(err);
    }
    // Try to normalize the op. This removes trailing skip:0&#x27;s and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = &#x27;floating&#x27;;
  }

  opData.type = this.type;
  opData.callbacks = [];

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var operation;
  var previous = this.pendingData[this.pendingData.length - 1];

  if (previous &#x26;&#x26; tryCompose(this.type, previous, opData)) {
    operation = previous;
  } else {
    operation = opData;
    this.pendingData.push(opData);
  }
  if (callback) operation.callbacks.push(callback);

  this._otApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn&#x27;t matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// @param operation handled by the OT type
// @param [context] editing context
// @param [callback] called after operation submitted
//
// @fires before op, op, after op
Doc.prototype.submitOp = function(op, context, callback) {
  this.<span class="apidocCodeKeywordSpan">_submitOpData</span>({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype._tryRollback" id="apidoc.element.share.client.Doc.prototype._tryRollback">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>_tryRollback
        <span class="apidocSignatureSpan">(opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_tryRollback = function (opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don&#x27;t think its possible to get here if we aren&#x27;t in a floating state.
    if (this.state === &#x27;floating&#x27;)
      this.state = null;
    else
      console.warn(&#x27;Rollback a create from state &#x27; + this.state);

  } else if (opData.op &#x26;&#x26; opData.type.invert) {
    opData.op = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i &#x3c; this.pendingData.length; i++) {
      xf(this.pendingData[i], opData);
    }

    // ... and apply it locally, reverting the changes.
    //
    // This operation is applied to look like it comes from a remote context.
    // I&#x27;m still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client&#x27;s op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(opData, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit(&#x27;error&#x27;, &#x22;Op apply failed and the operation could not be reverted&#x22;);

    // Trigger a fetch. In our invalid state, we can&#x27;t really do anything.
    this.fetch();
    this.flush();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// get sent our op back in the op stream (which happens even if we aren&#x27;t
// subscribed)
if (msg.error &#x26;&#x26; msg.error !== &#x27;Op already submitted&#x27;) {
  // The server has rejected an op from the client for an unexpected reason.
  // We&#x27;ll send the error message to the user and try to roll back the change.
  if (this.inflightData) {
    console.warn(&#x27;Operation was rejected (&#x27; + msg.error + &#x27;). Trying to rollback change locally.&#x27;);
    this.<span class="apidocCodeKeywordSpan">_tryRollback</span>(this.inflightData);
    this._clearInflightOp(msg.error);
  } else {
    // I managed to get into this state once. I&#x27;m not sure how it happened.
    // The op was maybe double-acknowledged?
    console.warn(&#x27;Second acknowledgement message (error) received&#x27;, msg, this);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.addListener" id="apidoc.element.share.client.Doc.prototype.addListener">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
SubDoc.prototype.add = function(path, amount, cb) {
  return normalizeArgs(this, arguments, function(path, amount, cb) {
    return this.context.add(path, amount, cb);
  });
};

SubDoc.prototype.on = function(event, cb) {
  return this.context.<span class="apidocCodeKeywordSpan">addListener</span>(this.path, event, cb);
};

SubDoc.prototype.removeListener = function(l) {
  return this.context.removeListener(l);
};

SubDoc.prototype.getLength = function(path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.attachTextarea" id="apidoc.element.share.client.Doc.prototype.attachTextarea">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>attachTextarea
        <span class="apidocSignatureSpan">(elem, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTextarea = function (elem, ctx) {
  if (!ctx) ctx = this.createContext();

  if (!ctx.provides.text) throw new Error(&#x27;Cannot attach to non-text document&#x27;);

  elem.value = ctx.get();

  // The current value of the element&#x27;s text is stored so we can quickly check
  // if its been changed in the event handlers. This is mostly for browsers on
  // windows, where the content contains \r\n newlines. applyChange() is only
  // called after the \r\n newlines are converted, and that check is quite
  // slow. So we also cache the string before conversion so we can do a quick
  // check incase the conversion isn&#x27;t needed.
  var prevvalue;

  // Replace the content of the text area with newText, and transform the
  // current cursor by the specified function.
  var replaceText = function(newText, transformCursor) {
    if (transformCursor) {
      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
    }

    // Fixate the window&#x27;s scroll while we set the element&#x27;s value. Otherwise
    // the browser scrolls to the element.
    var scrollTop = elem.scrollTop;
    elem.value = newText;
    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.
    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;

    // Setting the selection moves the cursor. We&#x27;ll just have to let your
    // cursor drift if the element isn&#x27;t active, though usually users don&#x27;t
    // care.
    if (newSelection &#x26;&#x26; window.document.activeElement === elem) {
      elem.selectionStart = newSelection[0];
      elem.selectionEnd = newSelection[1];
    }
  };

  replaceText(ctx.get());


  // *** remote -&#x3e; local changes

  ctx.onInsert = function(pos, text) {
    var transformCursor = function(cursor) {
      return pos &#x3c; cursor ? cursor + text.length : cursor;
    };

    // Remove any window-style newline characters. Windows inserts these, and
    // they mess up the generated diff.
    var prev = elem.value.replace(/\r\n/g, &#x27;\n&#x27;);
    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);
  };

  ctx.onRemove = function(pos, length) {
    var transformCursor = function(cursor) {
      // If the cursor is inside the deleted region, we only want to move back to the start
      // of the region. Hence the Math.min.
      return pos &#x3c; cursor ? cursor - Math.min(length, cursor - pos) : cursor;
    };

    var prev = elem.value.replace(/\r\n/g, &#x27;\n&#x27;);
    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);
  };


  // *** local -&#x3e; remote changes

  // This function generates operations from the changed content in the textarea.
  var genOp = function(event) {
    // In a timeout so the browser has time to propogate the event&#x27;s changes to the DOM.
    setTimeout(function() {
      if (elem.value !== prevvalue) {
        prevvalue = elem.value;
        applyChange(ctx, ctx.get(), elem.value.replace(/\r\n/g, &#x27;\n&#x27;));
      }
    }, 0);
  };

  var eventNames = [&#x27;textInput&#x27;, &#x27;keydown&#x27;, &#x27;keyup&#x27;, &#x27;select&#x27;, &#x27;cut&#x27;, &#x27;paste&#x27;];
  for (var i = 0; i &#x3c; eventNames.length; i++) {
    var e = eventNames[i];
    if (elem.addEventListener) {
      elem.addEventListener(e, genOp, false);
    } else {
      elem.attachEvent(&#x27;on&#x27; + e, genOp);
    }
  }

  ctx.detach = function() {
    for (var i = 0; i &#x3c; eventNames.length; i++) {
      var e = eventNames[i];
      if (elem.removeEventListener) {
        elem.removeEventListener(e, genOp, false);
      } else {
        elem.detachEvent(&#x27;on&#x27; + e, genOp);
      }
    }
  };

  return ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// This will be called when we have a live copy of the server&#x27;s data.
doc.whenReady(function() {
  console.log(&#x27;doc ready, data: &#x27;, doc.getSnapshot());

  // Create a JSON document with value x:5
  if (!doc.type) doc.create(&#x27;text&#x27;);
  doc.<span class="apidocCodeKeywordSpan">attachTextarea</span>(document.getElementById(&#x27;pad&#x27;));
});
```

And a JSON document:

```javascript
var socket = ...;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.create" id="apidoc.element.share.client.Doc.prototype.create">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>create
        <span class="apidocSignatureSpan">(type, data, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (type, data, context, callback) {
  if (typeof data === &#x27;function&#x27;) {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }

  if (this.type) {
    var err = &#x27;Document already exists&#x27;;
    if (callback) return callback(err);
    throw new Error(err);
  }

  var op = {create: {type:type, data:data}};
  this._submitOpData(op, context, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.<span class="apidocCodeKeywordSpan">create</span>(type, data,
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
&#x3e; initialize the document object with bundled data by calling
&#x3e; **doc.ingestData({type:..., data:...})**.

To call a method when a document has the current server data, pair your call to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.createContext" id="apidoc.element.share.client.Doc.prototype.createContext">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>createContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContext = function () {
  var type = this.type;
  if (!type) throw new Error(&#x27;Missing type &#x27; + this.collection + &#x27; &#x27; + this.name);

  // I could use the prototype chain to do this instead, but Object.create
  // isn&#x27;t defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don&#x27;t double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &#x26;
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      //
      // NOTE Why can&#x27;t we destroy contexts immediately?
      delete this._onOp;
      this.shouldBeRemoved = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don&#x27;t depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type&#x27;s API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
does get notified about the operations performed by other contexts editing
the same document. This solves the problem that multiple parts of your app may
bind to the same document.
2. Editing contexts mix in API methods for the OT type of the document. This
makes it easier to edit the document. Note that the JSON API is currently a
bit broken, so this is currently only useful for text documents.

Create a context using **context = doc.<span class="apidocCodeKeywordSpan">createContext</span>()**. Contexts have the
following methods &#x26; properties:

- **context.submitOp(op, callback)**: Wrapper for `doc.submitOp(op, context, callback)`.
- **context.\_onOp = function(op) {...}** This is a hook for you / the type API
to add your own logic when operations happen. If you&#x27;re using the text API,
bind to **context.onInsert = ...** and **context.onRemove = ...** instead.
- **context.destroy()**: Destroy the context. The context will stop getting
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.del" id="apidoc.element.share.client.Doc.prototype.del">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>del
        <span class="apidocSignatureSpan">(context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (context, callback) {
  if (!this.type) {
    var err = &#x27;Document does not exist&#x27;;
    if (callback) return callback(err);
    throw new Error(err);
  }

  this._submitOpData({del: true}, context, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- **doc.submitOp(op, [context], [callback])**: Submit an operation to the
document. The operation must be valid for the given OT type of the document.
See the [text document OT
spec](https://github.com/ottypes/text/blob/master/README.md) and the [JSON
document OT
spec](https://github.com/ottypes/json0/blob/master/README.md). Consider using a
context instead of calling submitOp directly. (Described below)
- **doc.<span class="apidocCodeKeywordSpan">del</span>([context], [callback])**: Delete the document on the server. The
document reference will become null.

In all cases, the `context` argument is a user data object which is passed to
all event emitters related to this operation. This is designed so data bindings
can easily ignore their own events.

The callback for all editing operations is optional and informational. It will
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.destroy" id="apidoc.element.share.client.Doc.prototype.destroy">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>destroy
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don&#x27;t care if there&#x27;s an error unsubscribing.

    if (doc.hasPending()) {
      doc.once(&#x27;nothing pending&#x27;, function() {
        doc.connection._destroyDoc(doc);
      });
    } else {
      doc.connection._destroyDoc(doc);
    }
    doc.removeContexts();
    if (callback) callback();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Document objects store your actual data in the client. They can be modified
syncronously and they can automatically sync their data with the server.
Document objects can be modified offline - they will send data to the server
when the client reconnects.

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.<span class="apidocCodeKeywordSpan">destroy</span>()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.emit" id="apidoc.element.share.client.Doc.prototype.emit">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

client.on(&#x27;message&#x27;, function(data) {
  stream.push(data);
});

client.on(&#x27;close&#x27;, function(reason) {
  stream.push(null);
  stream.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;close&#x27;);
});

stream.on(&#x27;end&#x27;, function() {
  client.close();
});

// Give the stream to sharejs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.eventNames" id="apidoc.element.share.client.Doc.prototype.eventNames">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.fetch" id="apidoc.element.share.client.Doc.prototype.fetch">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>fetch
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (callback) {
  this._setWantSubscribe(&#x27;fetch&#x27;, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.<span class="apidocCodeKeywordSpan">fetch</span>(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.create(type, data,
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.flush" id="apidoc.element.share.client.Doc.prototype.flush">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  // Ignore if we can&#x27;t send or we are already sending an op
  if (!this.connection.canSend || this.inflightData) return;

  // Pump and dump any no-ops from the front of the pending op list.
  var opData;
  while (this.pendingData.length &#x26;&#x26; isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i &#x3c; callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // Send first pending op unless paused
  if (!this.paused &#x26;&#x26; this.pendingData.length) {
    this._sendOpData();
    return;
  }

  // Ignore if an action is already in process
  if (this.action) return;
  // Once all ops are sent, perform subscriptions and fetches
  var version = (this.state === &#x27;ready&#x27;) ? this.version : null;

  if (this.subscribed &#x26;&#x26; !this.wantSubscribe) {
    this.action = &#x27;unsubscribe&#x27;;
    this.connection.sendUnsubscribe(this);

  } else if (!this.subscribed &#x26;&#x26; this.wantSubscribe === &#x27;fetch&#x27;) {
    this.action = &#x27;fetch&#x27;;
    this.connection.sendFetch(this, version);

  } else if (!this.subscribed &#x26;&#x26; this.wantSubscribe) {
    this.action = &#x27;subscribe&#x27;;
    this.connection.sendSubscribe(this, version);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected &#x26; reconnect.
Doc.prototype._onConnectionStateChanged = function() {
  if (this.connection.canSend) {
    this.<span class="apidocCodeKeywordSpan">flush</span>();
  } else {
    this.subscribed = false;
    this._clearAction();
  }
};

Doc.prototype._clearAction = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.getMaxListeners" id="apidoc.element.share.client.Doc.prototype.getMaxListeners">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.getSnapshot" id="apidoc.element.share.client.Doc.prototype.getSnapshot">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>getSnapshot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSnapshot = function () {
  return this.snapshot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the time you should call whenReady instead. The semantics are a little
different in each case - the subscribe / fetch callbacks are called when the
operation has completed (successfully or unsuccessfully). Its possible for a
subscription to fail, but succeed when the client reconnects. On the other
hand, whenReady is called once there&#x27;s data. It will not be called if there was
an error subscribing.

Once you have data, you should call **doc.<span class="apidocCodeKeywordSpan">getSnapshot</span>()** to get it. Note that
this returns the doc&#x27;s internal doc object. You should never modify the
snapshot directly - instead call doc.submitOp.

#### Editing documents

Documents follow the [sharejs / livedb object
model](https://github.com/share/livedb#data-model). All documents sort of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.hasPending" id="apidoc.element.share.client.Doc.prototype.hasPending">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>hasPending
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPending = function () {
  return this.action != null || this.inflightData != null || !!this.pendingData.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Unsubscribe and remove all editing contexts
 */
Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
// Don&#x27;t care if there&#x27;s an error unsubscribing.

if (doc.<span class="apidocCodeKeywordSpan">hasPending</span>()) {
  doc.once(&#x27;nothing pending&#x27;, function() {
    doc.connection._destroyDoc(doc);
  });
} else {
  doc.connection._destroyDoc(doc);
}
doc.removeContexts();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.ingestData" id="apidoc.element.share.client.Doc.prototype.ingestData">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>ingestData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ingestData = function (data) {
  if (typeof data.v !== &#x27;number&#x27;) {
    throw new Error(&#x27;Missing version in ingested data &#x27; + this.collection + &#x27; &#x27; + this.name);
  }
  if (this.state) {
    // Silently ignore if doc snapshot version is equal or newer
    // TODO: Investigate whether this should happen in practice or not
    if (this.version &#x3e;= data.v) return;
    console.warn(&#x27;Ignoring ingest data for&#x27;, this.collection, this.name,
      &#x27;\n  in state:&#x27;, this.state, &#x27;\n  version:&#x27;, this.version,
      &#x27;\n  snapshot:\n&#x27;, this.snapshot, &#x27;\n  incoming data:\n&#x27;, data);
    return;
  }

  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data;
  this._setType(data.type);

  this.state = &#x27;ready&#x27;;
  this.emit(&#x27;ready&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.create(type, data,
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
&#x3e; initialize the document object with bundled data by calling
&#x3e; **doc.<span class="apidocCodeKeywordSpan">ingestData</span>({type:..., data:...})**.

To call a method when a document has the current server data, pair your call to
subscribe with **doc.whenReady(function() { ... }**. Your function will be
called immediately if the document already has data.

Both subscribe and fetch take a callback which will be called when the
operation is complete. In ShareJS 0.8 this callback is being removed - most of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.listenerCount" id="apidoc.element.share.client.Doc.prototype.listenerCount">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.listeners" id="apidoc.element.share.client.Doc.prototype.listeners">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.on" id="apidoc.element.share.client.Doc.prototype.on">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
stream._write = function(chunk, encoding, callback) {
  if (client.state !== &#x27;closed&#x27;) {
    client.send(chunk);
  }
  callback();
};

client.<span class="apidocCodeKeywordSpan">on</span>(&#x27;message&#x27;, function(data) {
  stream.push(data);
});

client.on(&#x27;close&#x27;, function(reason) {
  stream.push(null);
  stream.emit(&#x27;close&#x27;);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.once" id="apidoc.element.share.client.Doc.prototype.once">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
// Don&#x27;t care if there&#x27;s an error unsubscribing.

if (doc.hasPending()) {
  doc.<span class="apidocCodeKeywordSpan">once</span>(&#x27;nothing pending&#x27;, function() {
    doc.connection._destroyDoc(doc);
  });
} else {
  doc.connection._destroyDoc(doc);
}
doc.removeContexts();
if (callback) callback();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.pause" id="apidoc.element.share.client.Doc.prototype.pause">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
can easily ignore their own events.

The callback for all editing operations is optional and informational. It will
be called when the operation has been acknowledged by the server.

To be notified when edits happen remotely, register for the &#x27;op&#x27; event. (See events section below).

If you want to pause sending operations to the server, call **doc.<span class="apidocCodeKeywordSpan">pause</span>()**.
This is useful if a user wants to edit a document without other people seeing
their changes. Call **doc.resume()** to unpause &#x26; send any pending changes to
the server.

#### Editing Contexts

The other option to edit documents is to use a **Document editing context**.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.prependListener" id="apidoc.element.share.client.Doc.prototype.prependListener">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.prependOnceListener" id="apidoc.element.share.client.Doc.prototype.prependOnceListener">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.removeAllListeners" id="apidoc.element.share.client.Doc.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
}

// emit removeListener for all listeners on all events
if (arguments.length === 0) {
  for (key in this._events) {
    if (key === &#x27;removeListener&#x27;) continue;
    this.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(key);
  }
  this.removeAllListeners(&#x27;removeListener&#x27;);
  this._events = {};
  return this;
}

listeners = this._events[type];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.removeContexts" id="apidoc.element.share.client.Doc.prototype.removeContexts">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeContexts
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeContexts = function () {
  for (var i = 0; i &#x3c; this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (doc.hasPending()) {
      doc.once(&#x27;nothing pending&#x27;, function() {
        doc.connection._destroyDoc(doc);
      });
    } else {
      doc.connection._destroyDoc(doc);
    }
    doc.<span class="apidocCodeKeywordSpan">removeContexts</span>();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.removeListener" id="apidoc.element.share.client.Doc.prototype.removeListener">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
EventEmitter.prototype.once = function(type, listener) {
if (!isFunction(listener))
  throw TypeError(&#x27;listener must be a function&#x27;);

var fired = false;

function g() {
  this.<span class="apidocCodeKeywordSpan">removeListener</span>(type, g);

  if (!fired) {
    fired = true;
    listener.apply(this, arguments);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.resume" id="apidoc.element.share.client.Doc.prototype.resume">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The callback for all editing operations is optional and informational. It will
be called when the operation has been acknowledged by the server.

To be notified when edits happen remotely, register for the &#x27;op&#x27; event. (See events section below).

If you want to pause sending operations to the server, call **doc.pause()**.
This is useful if a user wants to edit a document without other people seeing
their changes. Call **doc.<span class="apidocCodeKeywordSpan">resume</span>()** to unpause &#x26; send any pending changes to
the server.

#### Editing Contexts

The other option to edit documents is to use a **Document editing context**.
Document contexts are thin wrappers around submitOp which provide two benefits:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.retry" id="apidoc.element.share.client.Doc.prototype.retry">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function () {
  if (!this.inflightData) return;
  var threshold = 5000 * Math.pow(2, this.inflightData.retries);
  if (this.inflightData.sentAt &#x3c; Date.now() - threshold) {
    this.connection.emit(&#x27;retry&#x27;, this);
    this._sendOpData();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this._retryInterval != null) return;

  var connection = this;
  this._retryInterval = setInterval(function() {
    for (var collectionName in connection.collections) {
      var collection = connection.collections[collectionName];
      for (var docName in collection) {
        collection[docName].<span class="apidocCodeKeywordSpan">retry</span>();
      }
    }
  }, 1000);
};


// Set the connection&#x27;s state. The connection is basically a state machine.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.setMaxListeners" id="apidoc.element.share.client.Doc.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    m = EventEmitter.defaultMaxListeners;
  }

  if (m &#x26;&#x26; m &#x3e; 0 &#x26;&#x26; this._events[type].length &#x3e; m) {
    this._events[type].warned = true;
    console.error(&#x27;(node) warning: possible EventEmitter memory &#x27; +
                  &#x27;leak detected. %d listeners added. &#x27; +
                  &#x27;Use emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>() to increase limit.&#x27;,
                  this._events[type].length);
    if (typeof console.trace === &#x27;function&#x27;) {
      // not supported in IE 10
      console.trace();
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.submitOp" id="apidoc.element.share.client.Doc.prototype.submitOp">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>submitOp
        <span class="apidocSignatureSpan">(op, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">submitOp = function (op, context, callback) {
  this._submitOpData({op: op}, context, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- **doc.create(type, [data], [context], [callback])**: Create the document on
the server with the given type and initial data. Type will usually be &#x27;text&#x27;
or &#x27;json0&#x27;. Data specifies initial data for the document. For text documents,
this should be an initial string. For JSON documents, this should be JSON
stringify-able data. If unspecified, initial data is an empty string or null
for text and JSON, respectively.
- **doc.<span class="apidocCodeKeywordSpan">submitOp</span>(op, [context], [callback])**: Submit an operation to the
document. The operation must be valid for the given OT type of the document.
See the [text document OT
spec](https://github.com/ottypes/text/blob/master/README.md) and the [JSON
document OT
spec](https://github.com/ottypes/json0/blob/master/README.md). Consider using a
context instead of calling submitOp directly. (Described below)
- **doc.del([context], [callback])**: Delete the document on the server. The
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.subscribe" id="apidoc.element.share.client.Doc.prototype.subscribe">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (callback) {
  this._setWantSubscribe(true, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.<span class="apidocCodeKeywordSpan">subscribe</span>(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.unsubscribe" id="apidoc.element.share.client.Doc.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (callback) {
  this._setWantSubscribe(false, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.<span class="apidocCodeKeywordSpan">unsubscribe</span>([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.create(type, data,
callback)**.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.client.Doc.prototype.whenReady" id="apidoc.element.share.client.Doc.prototype.whenReady">
        function <span class="apidocSignatureSpan">share.client.Doc.prototype.</span>whenReady
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whenReady = function (fn) {
  if (this.state === &#x27;ready&#x27;) {
    fn();
  } else {
    this.once(&#x27;ready&#x27;, fn);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
&#x3e; initialize the document object with bundled data by calling
&#x3e; **doc.ingestData({type:..., data:...})**.

To call a method when a document has the current server data, pair your call to
subscribe with **doc.<span class="apidocCodeKeywordSpan">whenReady</span>(function() { ... }**. Your function will be
called immediately if the document already has data.

Both subscribe and fetch take a callback which will be called when the
operation is complete. In ShareJS 0.8 this callback is being removed - most of
the time you should call whenReady instead. The semantics are a little
different in each case - the subscribe / fetch callbacks are called when the
operation has completed (successfully or unsuccessfully). Its possible for a
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.connection" id="apidoc.module.share.connection">module share.connection</a></h1>


    <h2>
        <a href="#apidoc.element.share.connection.Connection" id="apidoc.element.share.connection.Connection">
        function <span class="apidocSignatureSpan">share.connection.</span>Connection
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Connection = function (socket) {
  emitter.EventEmitter.call(this);

  // Map of collection -&#x3e; docName -&#x3e; doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -&#x3e; query object.
  this.queries = {};

  // State of the connection. The correspoding events are emmited when this
  // changes. Available states are:
  // - &#x27;connecting&#x27;   The connection has been established, but we don&#x27;t have our
  //                  client ID yet
  // - &#x27;connected&#x27;    We have connected and recieved our client ID. Ready for data.
  // - &#x27;disconnected&#x27; The connection is closed, but it will reconnect automatically.
  // - &#x27;stopped&#x27;      The connection is closed, and should not reconnect.
  this.state = &#x27;disconnected&#x27;;

  // This is a helper variable the document uses to see whether we&#x27;re currently
  // in a &#x27;live&#x27; state. It is true if we&#x27;re connected, or if you&#x27;re using
  // browserchannel and connecting.
  this.canSend = false;

  // Private variable to support clearing of op retry interval
  this._retryInterval = null;

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  // I&#x27;ll store the most recent 100 messages so when errors occur we can see
  // what happened.
  this.messageBuffer = [];

  this.bindToSocket(socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The client needs a
[websocket](https://developer.mozilla.org/en-US/docs/WebSockets)-like session
object to communicate. You can use a normal websocket if you want:

```javascript
var ws = new WebSocket(&#x27;ws://&#x27; + window.location.host);
var share = new sharejs.<span class="apidocCodeKeywordSpan">Connection</span>(ws);
```

Sharejs also supports the following changes from the spec:

- The socket can reconnect. Simply call `socket.onopen` again when the socket
reconnects and sharejs will reestablish its session state and send any
outstanding user data.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db" id="apidoc.module.share.db">module share.db</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.client" id="apidoc.element.share.db.client">
        function <span class="apidocSignatureSpan">share.db.</span>client
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Livedb(options) {
  // Allow usage as
  //   var myClient = client(options);
  // or
  //   var myClient = new livedb.client(options);
  if (!(this instanceof Livedb)) return new Livedb(options);

  if (!options) throw new Error(&#x27;livedb missing database options&#x27;);

  if (options.redis)
    throw Error(&#x27;If you want to use redis, you need to instantiate the redis driver separately and provide it to livedb&#x27; +
       &#x27; via driver:livedb.redisDriver(db, redis, redisObserver&#x27;);

  // Database which stores the documents.
  this.snapshotDb = options.snapshotDb || options.db || options;

  if (!this.snapshotDb.getSnapshot || !this.snapshotDb.writeSnapshot) {
    throw new Error(&#x27;Missing or invalid snapshot db&#x27;);
  }

  this.driver = options.driver || require(&#x27;./inprocessdriver&#x27;)(options.oplog || options.db || options);

  // This contains any extra databases that can be queried &#x26; notified when documents change
  this.extraDbs = options.extraDbs || {};

  // Statsd client. Either accept a statsd client directly via options.statsd
  // or accept statsd options via options.statsd and create a statsd client
  // from them.
  if (options.sdc) {
    this.sdc = options.sdc;
  } else if (options.statsd) {
    if (!SDC) throw Error(&#x27;statsd not found - `npm install statsd` for statsd support&#x27;);
    this.sdc = new SDC(options.statsd);
    this.closeSdc = true;
  }
  if (this.sdc &#x26;&#x26; !this.driver.sdc) {
    this.driver.sdc = this.sdc;
  }

  // this.onOp = this.onOp.bind(this);
  bulkSubscribe.mixinSnapshotFn(this.snapshotDb);

  // Map from projected collection -&#x3e; {type, fields}
  this.projections = {};

  this.getDirtyDataPre = options.getDirtyDataPre || doNothing;
  this.getDirtyData = options.getDirtyData || doNothing;

  this.suppressCollectionPublish = !!options.suppressCollectionPublish;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To create a ShareJS server instance:

```javascript
var livedb = require(&#x27;livedb&#x27;);
var sharejs = require(&#x27;share&#x27;);

var backend = livedb.<span class="apidocCodeKeywordSpan">client</span>(livedb.memory());
var share = require(&#x27;share&#x27;).server.createClient({backend: backend});
```

The method is called `createClient` because its sort of a client of the
database... its a weird name, just roll with it.

The sharejs server instance has 3 methods you might care about:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver" id="apidoc.element.share.db.inprocessDriver">
        function <span class="apidocSignatureSpan">share.db.</span>inprocessDriver
        <span class="apidocSignatureSpan">(oplog)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InprocDriver(oplog) {
  if (!(this instanceof InprocDriver)) return new InprocDriver(oplog);

  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Emitter for channel messages. Ops are emitted on both the doc&#x27;s CD and its collection name.
  // Listener is called with (op, channel)
  this.subscribers = new EventEmitter();
  // We will be registering a lot of events. Surpress warnings.
  this.subscribers.setMaxListeners(0);

  // Bookkeeping simply so we can
  this.numStreams = 0;
  this.nextStreamId = 0;
  this.streams = {};

  // Map from list name -&#x3e; list of dirty data.
  this.dirtyLists = {};
  // A map from dirty list name -&#x3e; waiting callback
  this.dirtyWaiters = {};

  // Cache of CD -&#x3e; current doc version. This is needed because there&#x27;s a potential race condition
  // where getOps could be missing an operation thats just been processed and as a result we&#x27;ll
  // accept the same op for the same document twice. Data in here should be cleared out periodically
  // (like, 15 seconds after nobody has submitted to the document), but that logic hasn&#x27;t been
  // implemented yet.
  this.versions = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory" id="apidoc.element.share.db.memory">
        function <span class="apidocSignatureSpan">share.db.</span>memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  if (!(this instanceof Memory)) return new Memory();

  // Map from collection name -&#x3e; doc name -&#x3e; snapshot ({v:, type:, data:})
  this.collections = {};

  // Map from collection name -&#x3e; doc name -&#x3e; list of operations. Operations
  // don&#x27;t store their version - instead their version is simply the index in
  // the list.
  this.ops = {};

  this.closed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To create a ShareJS server instance:

```javascript
var livedb = require(&#x27;livedb&#x27;);
var sharejs = require(&#x27;share&#x27;);

var backend = livedb.client(livedb.<span class="apidocCodeKeywordSpan">memory</span>());
var share = require(&#x27;share&#x27;).server.createClient({backend: backend});
```

The method is called `createClient` because its sort of a client of the
database... its a weird name, just roll with it.

The sharejs server instance has 3 methods you might care about:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver" id="apidoc.element.share.db.redisDriver">
        function <span class="apidocSignatureSpan">share.db.</span>redisDriver
        <span class="apidocSignatureSpan">(oplog, client, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisDriver(oplog, client, observer) {
  if (!(this instanceof RedisDriver)) return new RedisDriver(oplog, client, observer);

  // Redis is used for atomic version incrementing, as an operation cache and for pubsub.
  this.redis = client || redisLib.createClient();

  // Persistant oplog.
  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Redis doesn&#x27;t allow the same connection to both listen to channels and do
  // operations. We make an extra redis connection for the streams.
  this.redisObserver = observer;
  if (!this.redisObserver) {
    // We can&#x27;t copy the selected db, but pubsub messages aren&#x27;t namespaced to their db anyway.
    // port and host are stored inside connectionOption object in redis &#x3e;= 0.12. previously they
    // were stored directly on the redis client itself.
    var port = this.redis.connectionOption ? this.redis.connectionOption.port : this.redis.port;
    var host = this.redis.connectionOption ? this.redis.connectionOption.host : this.redis.host;
    this.redisObserver = redisLib.createClient(this.redis.options, port, host);
    if (this.redis.auth_path) this.redisObserver.auth(this.redis.auth_pass);
    this.redisObserverCreated = true;
  }

  var self = this;
  this.redisObserver.on(&#x27;message&#x27;, function(channel, msg) {
    if (self.sdc) self.sdc.increment(&#x27;livedb.redis.message&#x27;);

    var data = JSON.parse(msg);

    var channelStreams = self.streams[channel];
    if (channelStreams) {
      for (var id in channelStreams) {
        channelStreams[id].pushOp(data);
      }
    }
    self.subscribers.emit(channel, channel, data);
  });

  // Emitter for channel messages. Event is the prefixed channel name. Listener is
  // called with (prefixed channel, msg)
  // TODO: This is only being used by the dirty queue now. It could probably
  // be removed and replaced with a simple map that would have less overhead
  this.subscribers = new EventEmitter();
  // Surpress max listener warnings
  this.subscribers.setMaxListeners(0);

  // For keeping track of streams
  this.nextStreamId = 0;
  this.numStreams = 0;
  // Maps channel -&#x3e; id -&#x3e; stream
  this.streams = {};

  // State for tracking subscriptions. We track this.subscribed separately from
  // the streams, since the stream gets added synchronously, and the subscribe
  // isn&#x27;t complete until the callback returns from Redis
  // Maps channel -&#x3e; true
  this.subscribed = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#redis.flushdb()

redisClient1 = redis.createClient(6379, &#x27;localhost&#x27;);
redisClient2 = redis.createClient(6379, &#x27;localhost&#x27;);

livedbLib = require &#x27;livedb&#x27;
memorydb  = livedbLib.memory()
driver = livedbLib.<span class="apidocCodeKeywordSpan">redisDriver</span>(memorydb, redisClient1, redisClient2);
livedb = livedbLib.client(db: memorydb, driver:driver)
livedb.redis = redisClient1
livedb.db = memorydb

shareServer = require &#x27;../../lib/server&#x27;
shareServer.createClient(backend: livedb)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.client" id="apidoc.module.share.db.client">module share.db.client</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.client.client" id="apidoc.element.share.db.client.client">
        function <span class="apidocSignatureSpan">share.db.</span>client
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Livedb(options) {
  // Allow usage as
  //   var myClient = client(options);
  // or
  //   var myClient = new livedb.client(options);
  if (!(this instanceof Livedb)) return new Livedb(options);

  if (!options) throw new Error(&#x27;livedb missing database options&#x27;);

  if (options.redis)
    throw Error(&#x27;If you want to use redis, you need to instantiate the redis driver separately and provide it to livedb&#x27; +
       &#x27; via driver:livedb.redisDriver(db, redis, redisObserver&#x27;);

  // Database which stores the documents.
  this.snapshotDb = options.snapshotDb || options.db || options;

  if (!this.snapshotDb.getSnapshot || !this.snapshotDb.writeSnapshot) {
    throw new Error(&#x27;Missing or invalid snapshot db&#x27;);
  }

  this.driver = options.driver || require(&#x27;./inprocessdriver&#x27;)(options.oplog || options.db || options);

  // This contains any extra databases that can be queried &#x26; notified when documents change
  this.extraDbs = options.extraDbs || {};

  // Statsd client. Either accept a statsd client directly via options.statsd
  // or accept statsd options via options.statsd and create a statsd client
  // from them.
  if (options.sdc) {
    this.sdc = options.sdc;
  } else if (options.statsd) {
    if (!SDC) throw Error(&#x27;statsd not found - `npm install statsd` for statsd support&#x27;);
    this.sdc = new SDC(options.statsd);
    this.closeSdc = true;
  }
  if (this.sdc &#x26;&#x26; !this.driver.sdc) {
    this.driver.sdc = this.sdc;
  }

  // this.onOp = this.onOp.bind(this);
  bulkSubscribe.mixinSnapshotFn(this.snapshotDb);

  // Map from projected collection -&#x3e; {type, fields}
  this.projections = {};

  this.getDirtyDataPre = options.getDirtyDataPre || doNothing;
  this.getDirtyData = options.getDirtyData || doNothing;

  this.suppressCollectionPublish = !!options.suppressCollectionPublish;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To create a ShareJS server instance:

```javascript
var livedb = require(&#x27;livedb&#x27;);
var sharejs = require(&#x27;share&#x27;);

var backend = livedb.<span class="apidocCodeKeywordSpan">client</span>(livedb.memory());
var share = require(&#x27;share&#x27;).server.createClient({backend: backend});
```

The method is called `createClient` because its sort of a client of the
database... its a weird name, just roll with it.

The sharejs server instance has 3 methods you might care about:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.client.prototype" id="apidoc.module.share.db.client.prototype">module share.db.client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.client.prototype._bulkSubscribeProjection" id="apidoc.element.share.db.client.prototype._bulkSubscribeProjection">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_bulkSubscribeProjection
        <span class="apidocSignatureSpan">(cName, docs, projection, results, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bulkSubscribeProjection = function (cName, docs, projection, results, done) {
  var requests = {};
  requests[projection.target] = docs;
  this.driver.bulkSubscribe(requests, function(err, subResult) {
    if (err) return done(err);

    var streams = subResult[projection.target];
    for (var docName in streams) {
      streams[docName] = wrapProjectedStream(streams[docName], projection);
    }
    results[cName] = streams;
    done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._dbQuery" id="apidoc.element.share.db.client.prototype._dbQuery">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_dbQuery
        <span class="apidocSignatureSpan">(db, index, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_dbQuery = function (db, index, query, options, callback) {
  var projection = this.projections[index];

  if (projection) {
    if (db.queryProjected)
      db.queryProjected(this, projection.target, projection.fields, query, options, callback);
    else {
      db.query(this, projection.target, query, options, function(err, results) {
        if (results) projectResults(results, index, projection);
        callback(err, results);
      });
    }
  } else {
    db.query(this, index, query, options, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._dbQueryDoc" id="apidoc.element.share.db.client.prototype._dbQueryDoc">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_dbQueryDoc
        <span class="apidocSignatureSpan">(db, index, docName, query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_dbQueryDoc = function (db, index, docName, query, callback) {
  var projection = this.projections[index];
  if (projection) {
    if (db.queryDocProjected) // What a mouthful!
      db.queryDocProjected(this, index, projection.target, docName, projection.fields, query, callback);
    else {
      db.queryDoc(this, index, projection.target, docName, query, function(err, result) {
        if (result) {
          result.data = projections.projectSnapshot(result.type, projection.fields, result.data);
        }
        callback(err, result);
      });
    }
  } else {
    db.queryDoc(this, index, index, docName, query, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._fetchPresence" id="apidoc.element.share.db.client.prototype._fetchPresence">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_fetchPresence
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fetchPresence = function (cName, docName, callback) {
  var cd = util.encodeCD(cName, docName);
  if (this.presenceCache[cd]) {
    return callback(null, this.presenceCache[cd]);
  }

  var self = this;
  this.oplog.getVersion(cName, docName, function(err, version) {
    self.presenceCache[cd] = {v:version, data:{}};
    callback(null, self.presenceCache[cd]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._getSnapshot" id="apidoc.element.share.db.client.prototype._getSnapshot">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_getSnapshot
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSnapshot = function (cName, docName, callback) {
  var projection = this.projections[cName];

  if (projection) {
    if (this.snapshotDb.getSnapshotProjected) {
      this.snapshotDb.getSnapshotProjected(projection.target, docName, projection.fields, function(err, snapshot) {
        if (snapshot &#x26;&#x26; snapshot.type !== projection.type) {
           // We&#x27;ll pretend the document doesn&#x27;t exist. Creating it will fail though - the document
           // isn&#x27;t invisible to the user.
          return callback(null, {v:snapshot.v});
        }
        callback(err, snapshot);
      });
    } else {
      this.snapshotDb.getSnapshot(projection.target, docName, function(err, snapshot) {
        if (err) return callback(err);

        if (snapshot) {
          if (snapshot.type !== projection.type)
            return callback(null, {v:snapshot.v});

          snapshot.data = projections.projectSnapshot(projection.type, projection.fields, snapshot.data);
        }

        callback(null, snapshot);
      });
    }
  } else {
    this.snapshotDb.getSnapshot(cName, docName, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._lazyFetch" id="apidoc.element.share.db.client.prototype._lazyFetch">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_lazyFetch
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lazyFetch = function (cName, docName, callback) {
  var self = this;
  var start = Date.now();

  this._getSnapshot(cName, docName, function(err, snapshot) {
    if (err) return callback(err);

    snapshot = snapshot || {v:0};
    if (snapshot.v == null) return callback(&#x27;Invalid snapshot data&#x27;);
    if (self.sdc) self.sdc.timing(&#x27;livedb.lazyFetch.called&#x27;, Date.now() - start);

    callback(null, snapshot);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._sdcDbPrefix" id="apidoc.element.share.db.client.prototype._sdcDbPrefix">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_sdcDbPrefix
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sdcDbPrefix = function (options) {
  return &#x27;livedb.db.&#x27; + ((options &#x26;&#x26; options.backend) ? options.backend : &#x27;default&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._trySubmit" id="apidoc.element.share.db.client.prototype._trySubmit">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_trySubmit
        <span class="apidocSignatureSpan">(submitData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trySubmit = function (submitData) {
  var self = this;
  var opData = submitData.opData;

  // First we&#x27;ll get a doc snapshot. This wouldn&#x27;t be necessary except that
  // we need to check that the operation is valid against the current
  // document before accepting it.
  this._lazyFetch(submitData.cName, submitData.docName, function(err, snapshot) {
    if (err) return submitData.callback(err);

    // Get all operations that might be relevant. We&#x27;ll float the snapshot
    // and the operation up to the most recent version of the document, then
    // try submitting.
    // If an incoming create operation, get the first op only, so that we can
    // check if it was a resubmission of the incoming op and return an
    // &#x27;Op already submitted&#x27; error, which is expected during normal operation
    // and is absorbed silently in the client
    var from = (opData.create) ? 0 :
      (opData.v != null &#x26;&#x26; opData.v &#x3c; snapshot.v) ? opData.v :
      snapshot.v;
    var to = (opData.create) ? 1 : null;
    self.driver.getOps(submitData.cName, submitData.docName, from, to, function(err, ops) {
      if (err) return submitData.callback(err);

      if (ops.length &#x26;&#x26; self.sdc)
        self.sdc.increment(&#x27;livedb.submit.transformNeeded&#x27;);

      if (submitData.expectTransform &#x26;&#x26; ops.length === 0) {
        console.warn(&#x22;ERROR: CORRUPT DATA DETECTED in document &#x22; + submitData.cName + &#x27;.&#x27; + submitData.docName);
        console.warn(&#x22;If you&#x27;re using redis, delete data for document. &#x22;
          + &#x22;Please file an issue if you can recreate this state reliably.&#x22;);
        submitData.callback(&#x27;Internal data corruption - cannot submit&#x27;);
        return;
      }

      for (var i = 0; i &#x3c; ops.length; i++) {
        var op = ops[i];

        if (opData.src &#x26;&#x26; opData.src === op.src &#x26;&#x26; opData.seq === op.seq) {
          // The op has already been submitted. There&#x27;s a variety of ways
          // this can happen. Its important we don&#x27;t transform it by itself
          // &#x26; submit again.
          submitData.callback(&#x27;Op already submitted&#x27;);
          return;
        }

        // Bring both the op and the snapshot up to date. At least one of
        // these two conditionals should be true.
        if (snapshot.v === op.v) {
          err = ot.apply(snapshot, op);
          if (err) return submitData.callback(err);
        }
        if (opData.v === op.v) {
          submitData.transformedOps.push(op);
          err = ot.transform(snapshot.type, opData, op);
          if (err) return submitData.callback(err);
        }
      }

      // Setting the version here has ramifications if we have to retry -
      // we&#x27;ll transform by any new operations which hit from this point on.
      // In reality, it shouldn&#x27;t matter. But its important to know that even
      // if you pass a null version into submit, its still possible for
      // transform() to get called.
      if (opData.v == null)
        opData.v = snapshot.v;
      else if (opData.v !== snapshot.v) {
        submitData.callback(&#x27;Invalid opData version&#x27;);
        return;
      }

      var type = snapshot.type;

      // We now have the type. If we&#x27;re being projected, verify that the op is allowed.
      if (submitData.projection &#x26;&#x26; !projections.isOpDataAllowed(type, submitData.projection.fields, opData)) {
        submitData.callback(&#x27;Operation invalid in projected collection&#x27;);
        return;
      }

      // Get the pre-apply dirty list data. This is a map from dirty list -&#x3e;
      // dirty list data blob.
      var dirtyData = self.getDirtyDataPre(submitData.cName, submitData.docName, opData, snapshot);

      // Ok, now we can try to apply the op.
      err = ot.apply(snapshot, opData);
      if (err) {
        if (typeof err !== &#x27;string&#x27; &#x26;&#x26; !util.isError(err)) {
          console.warn(&#x27;validation function must return falsy, string or an error object.&#x27;);
          console.warn(&#x27;Instead we got&#x27;, err);
        }

        submitData.callback(err);
        return;
      }

      var dirtyDataPost = self.getDirtyData(submitData.cName, submitData.docName, opData, snapshot);

      if (dirtyDataPost) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._updateCursors" id="apidoc.element.share.db.client.prototype._updateCursors">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_updateCursors
        <span class="apidocSignatureSpan">(cName, docName, type, opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateCursors = function (cName, docName, type, opData) {
  var cd = util.encodeCD(cName, docName);
  var p = this.presenceCache[cd];
  ot.updatePresence(type, p, opData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype._writeSnapshotAfterSubmit" id="apidoc.element.share.db.client.prototype._writeSnapshotAfterSubmit">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>_writeSnapshotAfterSubmit
        <span class="apidocSignatureSpan">(cName, docName, snapshot, opData, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writeSnapshotAfterSubmit = function (cName, docName, snapshot, opData, options, callback) {
  var self = this;

  this.snapshotDb.writeSnapshot(cName, docName, snapshot, function(err) {
    if (err) return callback(err);

    // For queries.
    for (var name in self.extraDbs) {
      var db = self.extraDbs[name];

      if (db.submit) {
        db.submit(cName, docName, opData, options, snapshot, self, function(err) {
          if (err) {
            console.warn(&#x22;Error updating db &#x22; + name + &#x22; &#x22; +
              cName + &#x22;.&#x22; + docName + &#x22; with new snapshot data: &#x22;, err);
          }
        });
      }
    }

    // It actually might make sense to hold calling the callback until after
    // all the database indexes have been updated. It might stop some race
    // conditions around external indexes.
    callback();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.addProjection" id="apidoc.element.share.db.client.prototype.addProjection">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>addProjection
        <span class="apidocSignatureSpan">(projName, cName, type, fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addProjection = function (projName, cName, type, fields) {
  if (this.projections[projName]) throw Error(&#x22;Projection &#x22; + projName + &#x22; already exists&#x22;);

  for (var k in fields) {
    if (fields[k] !== true) {
      throw Error(&#x22;Invalid field &#x22; + k +
        &#x22; - fields must be {&#x27;somekey&#x27;:true}. Subfields not currently supported.&#x22;);
    }
  }

  this.projections[projName] = {
    target: cName,
    type: ot.normalizeType(type),
    fields: fields
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.bulkFetch" id="apidoc.element.share.db.client.prototype.bulkFetch">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>bulkFetch
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkFetch = function (requests, callback) {
  var start = Date.now();
  var self = this;

  this.snapshotDb.bulkGetSnapshot(requests, function(err, results) {
    if (err) return callback(err);

    // We need to add {v:0} for missing snapshots in the results.
    for (var cName in requests) {
      var docs = requests[cName];
      for (var i = 0; i &#x3c; docs.length; i++) {
        var docName = docs[i];

        if (!results[cName][docName]) results[cName][docName] = {v:0};
      }
    }

    if (self.sdc) self.sdc.timing(&#x27;livedb.bulkFetch&#x27;, Date.now() - start);
    callback(null, results);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var self = this;
var agent = this.agent;

// Next we do a bulkFetch on all the items that need a fetchin&#x27;. If no
// documents need a fetch, this returns into the callback immediately.
agent.<span class="apidocCodeKeywordSpan">bulkFetch</span>(needFetch, function(err, snapshots) {
  if (err) {
    // For now, just abort the whole bundle on error. We could be more
    // neuanced about this, but I&#x27;ll wait for a use case.
    self._cancelBulk(request);
    return callback(err);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.bulkSubscribe" id="apidoc.element.share.db.client.prototype.bulkSubscribe">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>bulkSubscribe
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkSubscribe = function (requests, callback) {
  // This function has to deal with the annoying property that if you bulkSubscribe to a document
  // and bulkSubscribe to a projection of that document at the same time, we have to call
  // driver.bulkSubscribe multiple times. This is quite inefficient - and in reality, a client
  // shouldn&#x27;t really need multiple projections of the same document. When we revisit the API, I&#x27;ll
  // probably make this no longer necessary.

  var results = {};

  var work = 1;
  function done(err) {
    // TODO: This leaks memory if any of the bulkSubscribe requests fail.
    if (err &#x26;&#x26; callback) {
      callback(err);
      callback = null;
      return;
    }

    work--;
    if (!work) {
      callback(null, results);
    }
  }

  var nonProjectedRequests = {};
  var hasProjections = false; // Shortcut if there&#x27;s no projections to avoid the extra work.
  var self = this;

  for (var cName in requests) {
    var docs = requests[cName];
    var projection = this.projections[cName];
    if (!projection) {
      nonProjectedRequests[cName] = docs;
      continue;
    }
    hasProjections = true;

    // This could be more efficient - most of the time when you&#x27;re bulk subscribing to a projected
    // document, you won&#x27;t also bulk subscribe to its original. We could just transplant the
    // bulksubscribe request from the projection to the original. However, we&#x27;d still have to do
    // this work if you subscribed to more than one version of a document and that adds
    // complexity. This whole design is a bit awful, so I&#x27;m going to revisit it at some point -
    // and so this less efficient version will do for now.
    work++;
    this._bulkSubscribeProjection(cName, docs, projection, results, done);
  }

  if (hasProjections) {
    if (!livedbUtil.hasKeys(nonProjectedRequests)) {
      return done();
    }
    // Make a clone of the request object, omitting all the projected fields.
    this.driver.bulkSubscribe(nonProjectedRequests, function(err, r) {
      for (var cName in r) {
        results[cName] = r[cName];
      }
      done();
    });
  } else {
    // Don&#x27;t bother with any of the done() callback overhead.
    return this.driver.bulkSubscribe(requests, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Set the version that we&#x27;ll subscribe to
  request[cName][docName] = snapshot.v;
  // Set the snapshot in the response
  response[cName][docName] = snapshot;
}
    }

    agent.<span class="apidocCodeKeywordSpan">bulkSubscribe</span>(request, function(err, streams) {
if (err) {
  self._cancelBulk(request);
  return callback(err);
}

for (var cName in streams) {
  for (var docName in streams[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.collection" id="apidoc.element.share.db.client.prototype.collection">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>collection
        <span class="apidocSignatureSpan">(cName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collection = function (cName) {
  return {
    submit: this.submit.bind(this, cName),
    subscribe: this.subscribe.bind(this, cName),
    getOps: this.getOps.bind(this, cName),
    fetch: this.fetch.bind(this, cName),
    queryFetch: this.queryFetch.bind(this, cName),
    queryPoll: this.queryPoll.bind(this, cName),

    // Deprecated.
    query: this.query.bind(this, cName),
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.consumeDirtyData" id="apidoc.element.share.db.client.prototype.consumeDirtyData">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>consumeDirtyData
        <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consumeDirtyData = function (listName, options, consumeFn, callback) {
  // This is just a wrapper around the driver&#x27;s method with the same name.
  if (typeof options === &#x27;function&#x27;) {
    callback = consumeFn;
    consumeFn = options;
  }

  // Options are currently unused anyway...
  options = options || {};

  this.driver.consumeDirtyData(listName, options, consumeFn, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.destroy" id="apidoc.element.share.db.client.prototype.destroy">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  this.driver.destroy();

  // ... and close any remaining subscription streams.
  for (var id in this.streams) {
    this.streams[id].destroy();
  }

  if (this.closeSdc) this.sdc.close();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Document objects store your actual data in the client. They can be modified
syncronously and they can automatically sync their data with the server.
Document objects can be modified offline - they will send data to the server
when the client reconnects.

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.<span class="apidocCodeKeywordSpan">destroy</span>()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.fetch" id="apidoc.element.share.db.client.prototype.fetch">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetch
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (cName, docName, callback) {
  var self = this;
  var start = Date.now();

  this._lazyFetch(cName, docName, function(err, data) {
    if (err) return callback(err);

    self.getOps(cName, docName, data.v, function(err, results) {
      if (err) return callback(err);

      err = ot.applyAll(data, results);
      if (self.sdc) self.sdc.timing(&#x27;livedb.fetch.called&#x27;, Date.now() - start);
      callback(err, err ? null : data);

      // Note that this does NOT cache the new version in redis, unlike the old version.
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.<span class="apidocCodeKeywordSpan">fetch</span>(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.create(type, data,
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.fetchAndSubscribe" id="apidoc.element.share.db.client.prototype.fetchAndSubscribe">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetchAndSubscribe
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchAndSubscribe = function (cName, docName, callback) {
  var self = this;
  this.fetch(cName, docName, function(err, data) {
    if (err) return callback(err);
    self.subscribe(cName, docName, data.v, function(err, stream) {
      callback(err, data, stream);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return callback(err);
    }
    self._subscribeToStream(collection, docName, opstream);
    callback();
  });
} else {
  // Rewrite me to not use fetchAndSubscribe.
  this.agent.<span class="apidocCodeKeywordSpan">fetchAndSubscribe</span>(collection, docName, function(err, data, opstream) {
    if (err) {
      self._setSubscribed(collection, docName, false);
      return callback(err);
    }
    self._subscribeToStream(collection, docName, opstream);
    callback(null, data);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.fetchPresence" id="apidoc.element.share.db.client.prototype.fetchPresence">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>fetchPresence
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchPresence = function (cName, docName, callback) {
  this._fetchPresence(cName, docName, function(err, p) {
    callback(err, p ? p.data : null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.getOps" id="apidoc.element.share.db.client.prototype.getOps">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>getOps
        <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOps = function (cName, docName, from, to, callback) {
  // This function is basically just a fancy wrapper for driver.getOps(). Before
  // calling into the driver, it cleans up the input a little.

  // Make &#x27;to&#x27; field optional.
  if (typeof to === &#x27;function&#x27;) {
    callback = to;
    to = null;
  }

  var self = this;

  if (from == null) return callback(&#x27;Invalid from field in getOps&#x27;);

  if (to != null &#x26;&#x26; to &#x3e;= 0 &#x26;&#x26; from &#x3e; to) return callback(null, []);

  var start = Date.now();

  var projection = this.projections[cName];
  var c = projection ? projection.target : cName;

  this.driver.getOps(c, docName, from, to, function(err, ops) {
    if (self.sdc) self.sdc.timing(&#x27;livedb.getOps&#x27;, Date.now() - start);

    // Interestingly, this will filter ops for other types as if they were the projected type. This
    // is a bug, but it shouldn&#x27;t cause any problems for now. I&#x27;ll have to revisit this
    // implementation when we add support for projections on other types.
    if (ops &#x26;&#x26; projection) {
      for (var i = 0; i &#x3c; ops.length; i++) {
        ops[i] = projections.projectOpData(projection.type, projection.fields, ops[i]);
      }
    }
    callback(err, ops);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var from = 0, to = null;

  var query = url.parse(req.url, true).query;

  if (query &#x26;&#x26; query.from) from = parseInt(query.from)|0;
  if (query &#x26;&#x26; query.to) to = parseInt(query.to)|0;

  req._shareAgent.<span class="apidocCodeKeywordSpan">getOps</span>(req.params.cName, req.params.docName, from, to, function(err
, ops) {
    if (err)
      sendError(res, err);
    else
      sendJSON(res, ops);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.query" id="apidoc.element.share.db.client.prototype.query">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>query
        <span class="apidocSignatureSpan">(index, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (index, query, options, callback) {
  this.queryPoll(index, query, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      console.warn(&#x27;:,(&#x27;);
    }
    if (editorElem) contentArea.appendChild(editorElem);
  });
};

//q = sjs.<span class="apidocCodeKeywordSpan">query</span>(&#x27;users&#x27;, {&#x27;data.x&#x27;:5}, true, function(err, data) {
console.log(err, data); });
query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{&#x22;x&#x22;:5}}, {docMode:&#x27;sub&#x27;});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, &#x27;users&#x27;, {docMode:&#x27;fetch&#x27;});
//query = sjs.createSubscribeQuery(&#x27;stories&#x27;, {$query:{}}, {autoFetch:true});

//query = sjs.createSubscribeQuery(&#x27;players&#x27;, {&#x22;$orderby&#x22;:{&#x22;data.score&#x22;:-1},&#x22;$limit&#x22;:5}, {
autoFetch:true});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{}}, {autoFetch:true, source:&#x27;clock&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.queryFetch" id="apidoc.element.share.db.client.prototype.queryFetch">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>queryFetch
        <span class="apidocSignatureSpan">(index, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryFetch = function (index, query, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }

  var start = Date.now();
  var livedb = this;

  var db;
  if (options &#x26;&#x26; options.backend) {
    if (!this.extraDbs.hasOwnProperty(options.backend)) return callback(&#x27;Backend not found&#x27;);
    db = this.extraDbs[options.backend];
  } else {
    db = this.snapshotDb;
  }
  if (db.query.length &#x3c; 5)
    throw Error(&#x22;Livedb query backend &#x22; + (options.backend || &#x27;default&#x27;) + &#x22; is out of date &#x22; +
      &#x22;with spec (its probably missing the &#x27;options&#x27; parameter). Update your livedb backend library&#x22;);

  if (!this.snapshotDb.query) {
    return callback(&#x27;Backend does not support queries&#x27;);
  }

  this._dbQuery(db, index, query, {mode:&#x27;fetch&#x27;}, function(err, resultSet) {
    if (livedb.sdc) {
      var sdcPrefix = livedb._sdcDbPrefix(options);
      livedb.sdc.timing(sdcPrefix + &#x27;.query.fetch&#x27;, Date.now() - start);
    }

    if (err) {
      callback(err);
    } else if (Array.isArray(resultSet)) {
      callback(null, resultSet);
    } else {
      callback(null, resultSet.results, resultSet.extra);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


    // ********* Queries **********

    case &#x27;qfetch&#x27;:
      // Fetch the results of a query. This does not subscribe to the query or
      // anything, its just a once-off query fetch.
      agent.<span class="apidocCodeKeywordSpan">queryFetch</span>(index, req.q, qopts, function(err, results, extra) {
if (err) return callback(err);

// If the query subscribes to documents, the callback isn&#x27;t called
// until all the documents are subscribed.
var data = self._processQueryResults(req.c, results, qopts);

callback(null, {id:qid, data:data, extra:extra});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.queryPoll" id="apidoc.element.share.db.client.prototype.queryPoll">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>queryPoll
        <span class="apidocSignatureSpan">(index, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryPoll = function (index, query, options, callback) {
  if (!this.driver.subscribeCollection) return callback(&#x22;Driver does not support polling queries&#x22;);

  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (!options) {
    options = {};
  }

  var start = Date.now();
  var livedb = this;

  var db;
  if (options.backend) {
    if (!this.extraDbs.hasOwnProperty(options.backend)) return callback(&#x27;Backend not found&#x27;);
    db = this.extraDbs[options.backend];
  } else {
    db = this.snapshotDb;
  }

  if (db.disableSubscribe) {
    return callback(&#x27;Backend does not support subscribe&#x27;);
  }

  if (!this.snapshotDb.query) {
    return callback(&#x27;Backend does not support queries&#x27;);
  }

  var projection = this.projections[index];
  var collection = (projection) ? projection.target : index;
  // subscribe to collection firehose -&#x3e; cache. The firehose isn&#x27;t updated until after the db,
  // so if we get notified about an op here, the document&#x27;s been saved.
  this.driver.subscribeCollection(collection, function(err, stream) {
    if (err) return callback(err);
    if (livedb.sdc) {
      var sdcPrefix = livedb._sdcDbPrefix(options);
      livedb.sdc.timing(sdcPrefix + &#x27;.query.driverSubscribe&#x27;, Date.now() - start);
    }

    // Issue query on db to get our initial result set.
    livedb._dbQuery(db, index, query, {mode: &#x27;initial&#x27;}, function(err, resultSet) {
      if (err) {
        stream.destroy();
        return callback(err);
      }
      if (livedb.sdc) {
        var sdcPrefix = livedb._sdcDbPrefix(options);
        livedb.sdc.timing(sdcPrefix + &#x27;.query.subscribe&#x27;, Date.now() - start);
      }
      var results, extra;
      if (Array.isArray(resultSet)) {
        results = resultSet;
      } else {
        results = resultSet.results;
        extra = resultSet.extra;
      }
      var docNames = mapResults(results);
      var queryEmitter = new QueryEmitter(index, query, stream, docNames, extra, projection);
      var pollQuery = getPollQuery(livedb, db, options, queryEmitter)
      startStream(livedb, db, options, queryEmitter, collection, pollQuery);
      callback(null, queryEmitter, results, extra);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.submit" id="apidoc.element.share.db.client.prototype.submit">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>submit
        <span class="apidocSignatureSpan">(cName, docName, opData, submitOptions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">submit = function (cName, docName, opData, submitOptions, callback) {
  // Options is optional.
  if (typeof submitOptions === &#x27;function&#x27;) {
    callback = submitOptions;
    submitOptions = {};
  }

  if (!submitOptions) submitOptions = {};
  if (!callback) callback = doNothing;

  var err = ot.checkOpData(opData);
  if (err) return callback(err);

  ot.normalize(opData);

  // If its a projection, check the op with the projection and rewrite the call into a call against
  // the backing collection.
  var projection = this.projections[cName];
  if (projection) cName = projection.target;

  var submitData = new SubmitData(
    cName,
    docName,
    opData,
    submitOptions,
    projection,
    callback
  );

  this._trySubmit(submitData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  });

  var submit = function(req, res, opData, sendOps) {
    // The backend allows the version to be unspecified - it assumes the most
    // recent version in that case. This is useful behaviour when you want to
    // create a document.
    req._shareAgent.<span class="apidocCodeKeywordSpan">submit</span>(req.params.cName, req.params.docName, opData, {}, function
(err, v, ops) {
if (err) return sendError(res, err);

res.setHeader(&#x27;X-OT-Version&#x27;, v);
if (sendOps)
  sendJSON(res, ops);
else
  send200(res);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.submitPresence" id="apidoc.element.share.db.client.prototype.submitPresence">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>submitPresence
        <span class="apidocSignatureSpan">(cName, docName, pOp, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">submitPresence = function (cName, docName, pOp, callback) {
  var cd = util.encodeCD(cName, docName);
  var self = this;

  this._fetchPresence(cName, docName, function(err, p) {
    if (pOp.v == null || pOp.v === p.v) {
      // Support null / undefined version in opData
      apply();
    } else {
      this._getOps(cName, docName, pOp.v, null, apply);
    }

    function apply(err, ops) {
      if (err) return callback(err);

      if (ops) for (var i = 0; i &#x3c; ops.length; i++) {
        err = ot.transformPresence(&#x27;text&#x27;, p, pOp, ops[i]);
        if (err) return callback(err);
      }

      // console.log(&#x22;applyPresence&#x22;, p, pOp);

      if ((err = ot.applyPresence(p, pOp))) return callback(err);
      var channel = Livedb.getDocOpChannel(cName, docName);
      // self.subscribers.emit(channel, channel, {v:pOp.v, pOp:pOp});
      // console.log(&#x22;applyPresence&#x22;, p, pOp);
      callback();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.client.prototype.subscribe" id="apidoc.element.share.db.client.prototype.subscribe">
        function <span class="apidocSignatureSpan">share.db.client.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(cName, docName, v, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (cName, docName, v, options, callback) {
  // Support old option-less subscribe semantics
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  var projection = this.projections[cName];
  var c = projection ? projection.target : cName;

  this.driver.subscribe(c, docName, v, options, !projection ? callback : function(err, inStream) {
    // It seems a little roundabout, but we&#x27;ll wrap the stream in another stream to filter the ops.
    if (err) return callback(err);

    callback(null, wrapProjectedStream(inStream, projection));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.<span class="apidocCodeKeywordSpan">subscribe</span>(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.inprocessDriver" id="apidoc.module.share.db.inprocessDriver">module share.db.inprocessDriver</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.inprocessDriver" id="apidoc.element.share.db.inprocessDriver.inprocessDriver">
        function <span class="apidocSignatureSpan">share.db.</span>inprocessDriver
        <span class="apidocSignatureSpan">(oplog)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InprocDriver(oplog) {
  if (!(this instanceof InprocDriver)) return new InprocDriver(oplog);

  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Emitter for channel messages. Ops are emitted on both the doc&#x27;s CD and its collection name.
  // Listener is called with (op, channel)
  this.subscribers = new EventEmitter();
  // We will be registering a lot of events. Surpress warnings.
  this.subscribers.setMaxListeners(0);

  // Bookkeeping simply so we can
  this.numStreams = 0;
  this.nextStreamId = 0;
  this.streams = {};

  // Map from list name -&#x3e; list of dirty data.
  this.dirtyLists = {};
  // A map from dirty list name -&#x3e; waiting callback
  this.dirtyWaiters = {};

  // Cache of CD -&#x3e; current doc version. This is needed because there&#x27;s a potential race condition
  // where getOps could be missing an operation thats just been processed and as a result we&#x27;ll
  // accept the same op for the same document twice. Data in here should be cleared out periodically
  // (like, 15 seconds after nobody has submitted to the document), but that logic hasn&#x27;t been
  // implemented yet.
  this.versions = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.inprocessDriver.prototype" id="apidoc.module.share.db.inprocessDriver.prototype">module share.db.inprocessDriver.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype._checkForLeaks" id="apidoc.element.share.db.inprocessDriver.prototype._checkForLeaks">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_checkForLeaks
        <span class="apidocSignatureSpan">(allowSubscriptions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkForLeaks = function (allowSubscriptions, callback) {
  if (!allowSubscriptions &#x26;&#x26; this.numStreams) {
    console.log(this);
    throw Error(&#x27;Leak detected - still &#x27; + this.numStreams + &#x27; outstanding subscription(s)&#x27;);
  }

  if (Object.keys(this.streams).length !== this.numStreams) {
    console.error(&#x27;numStreams:&#x27;, this.numStreams, &#x27;this.streams:&#x27;, this.streams);
    throw Error(&#x27;this.numStreams does not match this.streams&#x27;);
  }

  // We should probably also check the listeners on the emitter.
  if (callback) callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype._cleanupStream" id="apidoc.element.share.db.inprocessDriver.prototype._cleanupStream">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_cleanupStream
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanupStream = function (stream) {
  if (!this.streams[stream._id]) return;
  this.numStreams--;
  delete this.streams[stream._id];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype._createStream" id="apidoc.element.share.db.inprocessDriver.prototype._createStream">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_createStream
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createStream = function (v) {
  var stream = new util.OpStream(v);

  // For cleanup.
  var id = stream._id = this.nextStreamId++;
  this.streams[id] = stream;
  this.numStreams++;

  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype._getOpsSince" id="apidoc.element.share.db.inprocessDriver.prototype._getOpsSince">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_getOpsSince
        <span class="apidocSignatureSpan">(cName, docName, version, results, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOpsSince = function (cName, docName, version, results, done) {
  this.oplog.getOps(cName, docName, version, null, function(err, ops) {
    if (err) return done(err);
    if (ops.length) results[cName][docName] = ops;
    done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype._subscribeNow" id="apidoc.element.share.db.inprocessDriver.prototype._subscribeNow">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>_subscribeNow
        <span class="apidocSignatureSpan">(cName, docName, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribeNow = function (cName, docName, v) {
  var stream = this._createStream(v);

  function listener(opData) {
    stream.pushOp(opData);
  }

  var cd = util.encodeCD(cName, docName);
  this.subscribers.on(cd, listener);

  var self = this;
  stream.once(&#x27;close&#x27;, function() {
    self.subscribers.removeListener(cd, listener);
    self._cleanupStream(stream);
  });

  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.appendDirtyData" id="apidoc.element.share.db.inprocessDriver.prototype.appendDirtyData">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>appendDirtyData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendDirtyData = function (data) {
  for (var listName in data) {
    if (!this.dirtyLists[listName]) this.dirtyLists[listName] = [];

    this.dirtyLists[listName].push(data[listName]);

    var fn = this.dirtyWaiters[listName];
    if (fn) {
      this.dirtyWaiters[listName] = null;
      fn();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.atomicSubmit" id="apidoc.element.share.db.inprocessDriver.prototype.atomicSubmit">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>atomicSubmit
        <span class="apidocSignatureSpan">(cName, docName, opData, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atomicSubmit = function (cName, docName, opData, options, callback) {
  // This is easy because we&#x27;re the only instance in the cluster, so anything
  // that happens syncronously in javascript is safe.

  var cd = util.encodeCD(cName, docName);
  if (this.versions[cd] != null &#x26;&#x26; this.versions[cd] &#x3e; opData.v) {
    process.nextTick(function() {
      callback(&#x22;Transform needed&#x22;);
    });
    return;
  }

  this.versions[cd] = opData.v + 1;

  if (options &#x26;&#x26; options.dirtyData) this.appendDirtyData(options.dirtyData);

  var self = this;
  this.oplog.writeOp(cName, docName, opData, function(err) {
    if (err) return callback(err);

    callback();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.bulkGetOpsSince" id="apidoc.element.share.db.inprocessDriver.prototype.bulkGetOpsSince">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>bulkGetOpsSince
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkGetOpsSince = function (requests, callback) {
  var results = {};
  var work = 1;
  var errored = false;
  function done(err) {
    if (errored) return;
    if (err) {
      errored = true;
      return callback(err);
    }
    work--;
    if (!work) callback(null, results);
  }
  var self = this;
  for (var cName in requests) {
    var versions = requests[cName];
    results[cName] = {};
    for (var docName in versions) {
      work++;
      self._getOpsSince(cName, docName, versions[docName], results, done);
    }
  }
  done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.bulkSubscribe" id="apidoc.element.share.db.inprocessDriver.prototype.bulkSubscribe">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>bulkSubscribe
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkSubscribe = function (requests, callback) {
  var self = this;

  // Map from cName -&#x3e; docName -&#x3e; stream.
  var results = {};

  for (var cName in requests) {
    var docs = requests[cName];
    results[cName] = {};
    for (var docName in docs) {
      var version = docs[docName];
      results[cName][docName] = self._subscribeNow(cName, docName, version);
    }
  }

  this.bulkGetOpsSince(requests, function(err, ops) {
    if (err) {
      for (var cName in results) {
        var streams = results[cName];
        for (var docName in docs) {
          streams[docName].destroy();
        }
      }
      callback(err);
    }

    // Map from cName -&#x3e; docName -&#x3e; stream.
    for (var cName in results) {
      var reqs = requests[cName];
      var streams = results[cName];
      for (var docName in reqs) {
        var o = ops[cName][docName];
        if (!o) continue;
        var version = reqs[docName];
        var stream = streams[docName];
        stream.pack(version, o);
      }
    }
    callback(null, results);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Set the version that we&#x27;ll subscribe to
  request[cName][docName] = snapshot.v;
  // Set the snapshot in the response
  response[cName][docName] = snapshot;
}
    }

    agent.<span class="apidocCodeKeywordSpan">bulkSubscribe</span>(request, function(err, streams) {
if (err) {
  self._cancelBulk(request);
  return callback(err);
}

for (var cName in streams) {
  for (var docName in streams[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.consumeDirtyData" id="apidoc.element.share.db.inprocessDriver.prototype.consumeDirtyData">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>consumeDirtyData
        <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consumeDirtyData = function (listName, options, consumeFn, callback) {
  if (this.dirtyWaiters[listName]) throw Error(&#x27;Cannot have multiple readers of the list&#x27;);

  var data = this.dirtyLists[listName];
  var wait = options.wait;
  var limit = options.limit;

  if (!data || data.length === 0) {
    if (!wait) return process.nextTick(callback);

    // Schedule consuming the slice when the data is here.
    var self = this;
    this.dirtyWaiters[listName] = function() {
      // This is easier than copy+pasting the above logic.
      self.consumeDirtyData(listName, options, consumeFn, callback);
    };
    return;
  }

  var slice = (limit &#x26;&#x26; data.length &#x3e; limit) ? data.slice(0, limit) : data;
  var num = slice.length;
  consumeFn(slice, function(err) {
    if (err) return callback(err);

    data.splice(0, num);
    callback();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.destroy" id="apidoc.element.share.db.inprocessDriver.prototype.destroy">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  // Dance!

  // .. We should close all the streams here.
  for (var id in this.streams) {
    var stream = this.streams[id];
    // This is a little inefficient - it removes the streams 1 by 1 from the subscribers event
    // emitter. We really just want to remove them all, and this way is n^2 with the number of
    // streams on a given document. But it should be fine for now.
    stream.destroy();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Document objects store your actual data in the client. They can be modified
syncronously and they can automatically sync their data with the server.
Document objects can be modified offline - they will send data to the server
when the client reconnects.

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.<span class="apidocCodeKeywordSpan">destroy</span>()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.getOps" id="apidoc.element.share.db.inprocessDriver.prototype.getOps">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>getOps
        <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOps = function (cName, docName, from, to, callback) {
  this.oplog.getOps(cName, docName, from, to, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var from = 0, to = null;

  var query = url.parse(req.url, true).query;

  if (query &#x26;&#x26; query.from) from = parseInt(query.from)|0;
  if (query &#x26;&#x26; query.to) to = parseInt(query.to)|0;

  req._shareAgent.<span class="apidocCodeKeywordSpan">getOps</span>(req.params.cName, req.params.docName, from, to, function(err
, ops) {
    if (err)
      sendError(res, err);
    else
      sendJSON(res, ops);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.postSubmit" id="apidoc.element.share.db.inprocessDriver.prototype.postSubmit">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>postSubmit
        <span class="apidocSignatureSpan">(cName, docName, opData, snapshot, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postSubmit = function (cName, docName, opData, snapshot, options) {
  opData.collection = cName;
  opData.docName = docName;

  // Post the change to anyone who&#x27;s interested.
  var cd = util.encodeCD(cName, docName);
  this.subscribers.emit(cd, opData);

  if (options &#x26;&#x26; options.suppressCollectionPublish) return;

  this.subscribers.emit(cName, opData, cName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.subscribe" id="apidoc.element.share.db.inprocessDriver.prototype.subscribe">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(cName, docName, v, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (cName, docName, v, options, callback) {
  var stream = this._subscribeNow(cName, docName, v);

  this.oplog.getOps(cName, docName, v, null, function(err, ops) {
    if (err) {
      stream.destroy();
      return callback(err);
    }

    stream.pack(v, ops);
    callback(null, stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.<span class="apidocCodeKeywordSpan">subscribe</span>(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.inprocessDriver.prototype.subscribeCollection" id="apidoc.element.share.db.inprocessDriver.prototype.subscribeCollection">
        function <span class="apidocSignatureSpan">share.db.inprocessDriver.prototype.</span>subscribeCollection
        <span class="apidocSignatureSpan">(cName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeCollection = function (cName, callback) {
  var stream = this._createStream();

  function listener(opData, channel) {
    // This is all a bit of a hack. When we have proper indexing, I&#x27;d love to rip this code out.
    opData.channel = channel;
    stream.push(opData);
  }

  this.subscribers.on(cName, listener);

  var self = this;
  stream.once(&#x27;close&#x27;, function() {
    self.subscribers.removeListener(cName, listener);
    self._cleanupStream(stream);
  });

  process.nextTick(function() {
    callback(null, stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.memory" id="apidoc.module.share.db.memory">module share.db.memory</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.memory.memory" id="apidoc.element.share.db.memory.memory">
        function <span class="apidocSignatureSpan">share.db.</span>memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  if (!(this instanceof Memory)) return new Memory();

  // Map from collection name -&#x3e; doc name -&#x3e; snapshot ({v:, type:, data:})
  this.collections = {};

  // Map from collection name -&#x3e; doc name -&#x3e; list of operations. Operations
  // don&#x27;t store their version - instead their version is simply the index in
  // the list.
  this.ops = {};

  this.closed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To create a ShareJS server instance:

```javascript
var livedb = require(&#x27;livedb&#x27;);
var sharejs = require(&#x27;share&#x27;);

var backend = livedb.client(livedb.<span class="apidocCodeKeywordSpan">memory</span>());
var share = require(&#x27;share&#x27;).server.createClient({backend: backend});
```

The method is called `createClient` because its sort of a client of the
database... its a weird name, just roll with it.

The sharejs server instance has 3 methods you might care about:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.memory.prototype" id="apidoc.module.share.db.memory.prototype">module share.db.memory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.memory.prototype._getOpLog" id="apidoc.element.share.db.memory.prototype._getOpLog">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>_getOpLog
        <span class="apidocSignatureSpan">(cName, docName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOpLog = function (cName, docName) {
  var c = this.ops[cName];
  if (!c) c = this.ops[cName] = {};

  var ops = c[docName] || (c[docName] = []);
  return ops;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype._getSnapshotSync" id="apidoc.element.share.db.memory.prototype._getSnapshotSync">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>_getSnapshotSync
        <span class="apidocSignatureSpan">(cName, docName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSnapshotSync = function (cName, docName) {
  var collection = this.collections[cName];
  // We need to clone the snapshot because at the moment LiveDB&#x27;s validation
  // code assumes each call to getSnapshot returns a new object.
  return collection &#x26;&#x26; clone(collection[docName]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.bulkGetSnapshot" id="apidoc.element.share.db.memory.prototype.bulkGetSnapshot">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>bulkGetSnapshot
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkGetSnapshot = function (requests, callback) {
  var results = {};
  for (var cName in requests) {
    var cResult = results[cName] = {};
    var docNames = requests[cName];
    for (var i = 0; i &#x3c; docNames.length; i++) {
      var docName = docNames[i];
      var snapshot = this._getSnapshotSync(cName, docName);
      if (snapshot) cResult[docName] = snapshot;
    }
  }
  process.nextTick(function() {
    callback(null, results);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.close" id="apidoc.element.share.db.memory.prototype.close">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
  this.closed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.on(&#x27;close&#x27;, function(reason) {
    stream.push(null);
    stream.emit(&#x27;close&#x27;);
  });

  stream.on(&#x27;end&#x27;, function() {
    client.<span class="apidocCodeKeywordSpan">close</span>();
  });

  // Give the stream to sharejs
  return share.listen(stream);
}));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.getOps" id="apidoc.element.share.db.memory.prototype.getOps">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getOps
        <span class="apidocSignatureSpan">(cName, docName, start, end, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOps = function (cName, docName, start, end, callback) {
  var opLog = this._getOpLog(cName, docName);
  if (end == null) {
    end = opLog.length;
  }
  var ops = opLog.slice(start, end);
  process.nextTick(function() {
    callback(null, ops);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var from = 0, to = null;

  var query = url.parse(req.url, true).query;

  if (query &#x26;&#x26; query.from) from = parseInt(query.from)|0;
  if (query &#x26;&#x26; query.to) to = parseInt(query.to)|0;

  req._shareAgent.<span class="apidocCodeKeywordSpan">getOps</span>(req.params.cName, req.params.docName, from, to, function(err
, ops) {
    if (err)
      sendError(res, err);
    else
      sendJSON(res, ops);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.getSnapshot" id="apidoc.element.share.db.memory.prototype.getSnapshot">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getSnapshot
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSnapshot = function (cName, docName, callback) {
  var snapshot = this._getSnapshotSync(cName, docName);
  process.nextTick(function() {
    callback(null, snapshot);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the time you should call whenReady instead. The semantics are a little
different in each case - the subscribe / fetch callbacks are called when the
operation has completed (successfully or unsuccessfully). Its possible for a
subscription to fail, but succeed when the client reconnects. On the other
hand, whenReady is called once there&#x27;s data. It will not be called if there was
an error subscribing.

Once you have data, you should call **doc.<span class="apidocCodeKeywordSpan">getSnapshot</span>()** to get it. Note that
this returns the doc&#x27;s internal doc object. You should never modify the
snapshot directly - instead call doc.submitOp.

#### Editing documents

Documents follow the [sharejs / livedb object
model](https://github.com/share/livedb#data-model). All documents sort of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.getVersion" id="apidoc.element.share.db.memory.prototype.getVersion">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>getVersion
        <span class="apidocSignatureSpan">(cName, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersion = function (cName, docName, callback) {
  var opLog = this._getOpLog(cName, docName);
  var version = opLog.length;
  process.nextTick(function() {
    callback(null, version);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.query" id="apidoc.element.share.db.memory.prototype.query">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>query
        <span class="apidocSignatureSpan">(liveDb, index, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (liveDb, index, query, options, callback) {
  var collection = this.collections[index];
  var results = [];
  for (var docName in collection || {}) {
    var snapshot = collection[docName];
    if (!snapshot.type) continue;
    var result = clone(snapshot);
    result.docName = docName;
    results.push(result);
  }
  process.nextTick(function() {
    callback(null, results);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      console.warn(&#x27;:,(&#x27;);
    }
    if (editorElem) contentArea.appendChild(editorElem);
  });
};

//q = sjs.<span class="apidocCodeKeywordSpan">query</span>(&#x27;users&#x27;, {&#x27;data.x&#x27;:5}, true, function(err, data) {
console.log(err, data); });
query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{&#x22;x&#x22;:5}}, {docMode:&#x27;sub&#x27;});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, &#x27;users&#x27;, {docMode:&#x27;fetch&#x27;});
//query = sjs.createSubscribeQuery(&#x27;stories&#x27;, {$query:{}}, {autoFetch:true});

//query = sjs.createSubscribeQuery(&#x27;players&#x27;, {&#x22;$orderby&#x22;:{&#x22;data.score&#x22;:-1},&#x22;$limit&#x22;:5}, {
autoFetch:true});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{}}, {autoFetch:true, source:&#x27;clock&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.queryDoc" id="apidoc.element.share.db.memory.prototype.queryDoc">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>queryDoc
        <span class="apidocSignatureSpan">(liveDb, index, cName, docName, query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryDoc = function (liveDb, index, cName, docName, query, callback) {
  var snapshot = this._getSnapshotSync(cName, docName);
  var result;
  if (snapshot &#x26;&#x26; snapshot.type) {
    result = snapshot;
    result.docName = docName;
  }
  process.nextTick(function() {
    callback(null, result);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.queryNeedsPollMode" id="apidoc.element.share.db.memory.prototype.queryNeedsPollMode">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>queryNeedsPollMode
        <span class="apidocSignatureSpan">(index, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryNeedsPollMode = function (index, query) {
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.writeOp" id="apidoc.element.share.db.memory.prototype.writeOp">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>writeOp
        <span class="apidocSignatureSpan">(cName, docName, opData, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOp = function (cName, docName, opData, callback) {
  var opLog = this._getOpLog(cName, docName);

  // This should never actually happen unless there&#x27;s bugs in livedb. (Or you
  // try to use this memory implementation with multiple frontend servers)
  if (opLog.length &#x3c; opData.v - 1) {
    return callback(&#x27;Internal consistancy error - database missing parent version&#x27;);
  }

  opLog[opData.v] = opData;
  process.nextTick(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.memory.prototype.writeSnapshot" id="apidoc.element.share.db.memory.prototype.writeSnapshot">
        function <span class="apidocSignatureSpan">share.db.memory.prototype.</span>writeSnapshot
        <span class="apidocSignatureSpan">(cName, docName, snapshot, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeSnapshot = function (cName, docName, snapshot, callback) {
  var c = this.collections[cName] = (this.collections[cName] || {});
  c[docName] = clone(snapshot);
  process.nextTick(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.ot" id="apidoc.module.share.db.ot">module share.db.ot</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.ot.apply" id="apidoc.element.share.db.ot.apply">
        function <span class="apidocSignatureSpan">share.db.ot.</span>apply
        <span class="apidocSignatureSpan">(data, opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (data, opData) {
  var err;

  if (typeof opData !== &#x27;object&#x27;)
    return &#x27;Missing data&#x27;;
  // if (!(typeof (opData.op || opData.create) === &#x27;object&#x27; || opData.del === true))
  //   return &#x27;Missing op&#x27;;

  if ((data.v != null) &#x26;&#x26; (opData.v != null) &#x26;&#x26; data.v !== opData.v)
    return &#x27;Version mismatch&#x27;;

  var validate = opData.validate || defaultValidate;
  var preValidate = opData.preValidate || defaultValidate;

  if (opData.create) { // Create operations
    if (data.type) return &#x27;Document already exists&#x27;;

    // The document doesn&#x27;t exist, although it might have once existed.
    var create = opData.create;
    var type = otTypes[create.type];
    if (!type) return &#x22;Type not found&#x22;;

    if ((err = preValidate(opData, data))) return err;

    var snapshot = type.create(create.data);
    data.data = snapshot;
    data.type = type.uri;
    data.v++;

    // metadata
    if (create.m != null &#x26;&#x26; typeof create.m !== &#x27;object&#x27;)
      return &#x27;Invalid metadata in create&#x27;

    var meta = create.m || {};
    meta.ctime = meta.mtime = Date.now();
    data.m = meta;

    if ((err = validate(opData, data))) return err;

  } else if (opData.del) { // Delete operations
    if ((err = preValidate(opData, data))) return err;

    opData.prev = {data:data.data, type:data.type};
    delete data.data;
    delete data.type;
    data.v++;

    // Previously we were deleting the metadata by default. We should include it
    // by default for consistancy with other ops and allow users to remove it in the
    // post validation phase if they really don&#x27;t want it to stay in the snapshot
    //delete data.m
    var meta = data.m || {};
    meta.mtime = Date.now();
    data.m = meta;

    if ((err = validate(opData, data))) return err;

    // Don&#x27;t leak prev past this function - it has security implications with projections.
    delete opData.prev;

  } else if (opData.op) { // Edit operations
    if (!data.type) return &#x27;Document does not exist&#x27;;

    var op = opData.op;
    if (typeof op !== &#x27;object&#x27;) return &#x27;Missing op&#x27;;
    var type = otTypes[data.type];
    if (!type) return &#x27;Type not found&#x27;;

    try {
      // This shattering stuff is a little bit dodgy. Its important because it
      // lets the OT type apply the operation incrementally, which means the
      // operation can be validated piecemeal. (Even though the entire
      // operation is accepted or rejected wholesale). Racer uses this, but
      // I&#x27;m convinced its not the right API. I want to remove / rewrite this
      // when I think of something to replace it with.
      var atomicOps = type.shatter ? type.shatter(op) : [op];
      for (var i = 0; i &#x3c; atomicOps.length; i++) {
        var atom = atomicOps[i];
        opData.op = atom;
        if ((err = preValidate(opData, data))) {
          opData.op = op;
          return err;
        }

        // !! The money line.
        data.data = type.apply(data.data, atom);

        if ((err = validate(opData, data))) {
          opData.op = op;
          return err;
        }
      }
      // Make sure to restore the operation before returning.
      opData.op = op;

    } catch (err) {
      console.log(err.stack);
      return err.message;
    }

    data.m = data.m || {};
    data.m.mtime = Date.now();
    data.v++;
  } else {
    // Its a no-op, and we don&#x27;t have to do anything.
    data.v++;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
if (data1.create &#x26;&#x26; data2.del) {
  setNoOp(data1);
} else if (data1.create &#x26;&#x26; data2.op) {
  // Compose the data into the create data.
  var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
  data1.create.data = type.<span class="apidocCodeKeywordSpan">apply</span>(data, data2.op);
} else if (isNoOp(data1)) {
  data1.create = data2.create;
  data1.del = data2.del;
  data1.op = data2.op;
} else if (data1.op &#x26;&#x26; data2.op &#x26;&#x26; type.compose) {
  data1.op = type.compose(data1.op, data2.op);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.applyAll" id="apidoc.element.share.db.ot.applyAll">
        function <span class="apidocSignatureSpan">share.db.ot.</span>applyAll
        <span class="apidocSignatureSpan">(data, ops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyAll = function (data, ops) {
  var err;
  if (ops.length) {
    for (var i = 0; i &#x3c; ops.length; i++) {
      if ((err = apply(data, ops[i]))) return err;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.applyPresence" id="apidoc.element.share.db.ot.applyPresence">
        function <span class="apidocSignatureSpan">share.db.ot.</span>applyPresence
        <span class="apidocSignatureSpan">(p, pOp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyPresence = function (p, pOp) {
  var container = p;
  var key = &#x27;data&#x27;;
  var value = pOp.val;
  var err;

  if (pOp.p) {
    if (!Array.isArray(pOp.p)) return &#x27;Path must be an array&#x27;;

    // This is really gross...... :/
    if (pOp.p.length &#x3e;= 2) {
      if ((err = checkKey(pOp.p[1]))) return err;
    } else if (pOp.p.length === 1) {
      // Setting an entire user&#x27;s presence data
      for (var k in value) {
        if ((err = checkKey(k))) return err;
      }
    }
  }

  // Not checking keys for ops with no path - I figure only the server will be
  // allowed to wholesale overwrite the presence data of a document, and in
  // that case I&#x27;m not overly concerned.

  if (pOp.p) for (var i = 0; i &#x3c; pOp.p.length; i++) {
    if (container[key] == null) {
      if (value == null) return;
      container[key] = {};
    }
    container = container[key];
    key = pOp.p[i];

    if (typeof key !== &#x27;string&#x27;) return &#x27;Cannot use non-string key&#x27;;
  }
  if (value == null) {
    if (container === p) {
      // Don&#x27;t delete the root object, just replace it with {}.
      container.data = {};
    } else {
      delete container[key];
    }
  } else {
    container[key] = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.checkOpData" id="apidoc.element.share.db.ot.checkOpData">
        function <span class="apidocSignatureSpan">share.db.ot.</span>checkOpData
        <span class="apidocSignatureSpan">(opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkOpData = function (opData) {
  if (typeof opData !== &#x27;object&#x27;) return &#x27;Missing opData&#x27;;

  if (typeof (opData.op || opData.create) !== &#x27;object&#x27; &#x26;&#x26; opData.del !== true) return &#x27;Missing op1&#x27;;

  if (opData.create) {
    var typeStr = opData.create.type;
    if (typeof typeStr !== &#x27;string&#x27;) return &#x27;Missing create type&#x27;;
    var type = otTypes[typeStr];
    if (type == null || typeof type !== &#x27;object&#x27;) return &#x27;Unknown type&#x27;;
  }

  if ((opData.src != null) &#x26;&#x26; typeof opData.src !== &#x27;string&#x27;) return &#x27;Invalid src&#x27;;
  if ((opData.seq != null) &#x26;&#x26; typeof opData.seq !== &#x27;number&#x27;) return &#x27;Invalid seq&#x27;;
  if (!!opData.seq !== !!opData.src) return &#x27;seq but not src&#x27;;

  if (opData.m != null &#x26;&#x26; typeof opData.m !== &#x27;object&#x27;) return &#x27;opData.m invalid&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.normalize" id="apidoc.element.share.db.ot.normalize">
        function <span class="apidocSignatureSpan">share.db.ot.</span>normalize
        <span class="apidocSignatureSpan">(opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalize = function (opData) {
  // I&#x27;d love to also normalize opData.op if it exists, but I don&#x27;t know the
  // type of the operation. And I can&#x27;t find that out until after transforming
  // the operation anyway.
  if (opData.create) {
    // Store the full URI of the type, not just its short name
    opData.create.type = normalizeType(opData.create.type);
  }

  if (opData.m == null) opData.m = {};
  if (!opData.src) opData.src = &#x27;&#x27;;
  opData.m.ts = Date.now();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (opData.op) {
  if (!this.type) {
    var err = &#x27;Document has not been created&#x27;;
    if (callback) return callback(err);
    throw new Error(err);
  }
  // Try to normalize the op. This removes trailing skip:0&#x27;s and things like that.
  if (this.type.normalize) opData.op = this.type.<span class="apidocCodeKeywordSpan">normalize</span>(opData.op);
}

if (!this.state) {
  this.state = &#x27;floating&#x27;;
}

opData.type = this.type;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.normalizeType" id="apidoc.element.share.db.ot.normalizeType">
        function <span class="apidocSignatureSpan">share.db.ot.</span>normalizeType
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeType = function (typeName) {
  return otTypes[typeName].uri;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.registerType" id="apidoc.element.share.db.ot.registerType">
        function <span class="apidocSignatureSpan">share.db.ot.</span>registerType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerType = function (type) {
  if (typeof type === &#x27;string&#x27;) type = require(type).type;
  if (type.name) otTypes[type.name] = type;
  if (type.uri) otTypes[type.uri] = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.ottypes = {};
exports.registerType = function(type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
};

exports.<span class="apidocCodeKeywordSpan">registerType</span>(require(&#x27;ot-json0&#x27;).type);
exports.registerType(require(&#x27;ot-text&#x27;).type);
exports.registerType(require(&#x27;ot-text-tp2&#x27;).type);

// The types register themselves on their respective types.
require(&#x27;./text-api&#x27;);
require(&#x27;./text-tp2-api&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.transform" id="apidoc.element.share.db.ot.transform">
        function <span class="apidocSignatureSpan">share.db.ot.</span>transform
        <span class="apidocSignatureSpan">(type, opData, appliedOpData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transform = function (type, opData, appliedOpData) {
  // There are 16 cases this function needs to deal with - which are all the
  // combinations of create/delete/op/noop from both opData and appliedOpData.
  //
  // This function was carefully written before noop, but now its a bit of a mess. I want schematic
  // tables!
  if ((opData.v != null) &#x26;&#x26; opData.v !== appliedOpData.v)
    return &#x27;Version mismatch&#x27;;

  if (appliedOpData.del) {
    if (opData.create || opData.op) return &#x27;Document was deleted&#x27;;
  } else if ((appliedOpData.create &#x26;&#x26; (opData.op || opData.create || opData.del))
      || (appliedOpData.op &#x26;&#x26; opData.create)) {
    // If appliedOpData.create is not true, appliedOpData contains an op - which
    // also means the document exists remotely.
    return &#x27;Document created remotely&#x27;;
  } else if (appliedOpData.op &#x26;&#x26; opData.op) {
    // If we reach here, they both have a .op property.
    if (!type) return &#x27;Document does not exist&#x27;;

    if (typeof type === &#x27;string&#x27;) {
      type = otTypes[type];
      if (!type) return &#x22;Type not found&#x22;;
    }

    try {
      opData.op = type.transform(opData.op, appliedOpData.op, &#x27;left&#x27;);
    } catch (e) {
      return e.message;
    }
  }

  if (opData.v != null) opData.v++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 // might be undefined or a totally different type. By pinning the type to the
 // op data, we make sure the right type has its transform function called.
 if (client.type.transformX) {
   var result = client.type.transformX(client.op, server.op);
   client.op = result[0];
   server.op = result[1];
 } else {
   var _c = client.type.<span class="apidocCodeKeywordSpan">transform</span>(client.op, server.op, &#x27;left&#x27;);
   var _s = client.type.transform(server.op, client.op, &#x27;right&#x27;);
   client.op = _c; server.op = _s;
 }
};

/**
* Applies the operation to the snapshot
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.transformPresence" id="apidoc.element.share.db.ot.transformPresence">
        function <span class="apidocSignatureSpan">share.db.ot.</span>transformPresence
        <span class="apidocSignatureSpan">(type, p, pOp, opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transformPresence = function (type, p, pOp, opData) {
  if (typeof type === &#x27;string&#x27;) {
    type = otTypes[type];
    if (!type) return &#x22;Type not found&#x22;;
  }

  if (!type.transformCursor) return;

  // This is not complete. .... ........
  if (pOp.p &#x26;&#x26; pOp.p.length === 2 &#x26;&#x26; pOp.p[1] === &#x27;cursor&#x27; &#x26;&#x26; opData.op) {
    // Gasp...
    pOp.val = type.transformCursor(pOp.val, opData.op, pOp.p[0] === opData.src);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.ot.updatePresence" id="apidoc.element.share.db.ot.updatePresence">
        function <span class="apidocSignatureSpan">share.db.ot.</span>updatePresence
        <span class="apidocSignatureSpan">(type, p, opData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatePresence = function (type, p, opData) {
  if (!p) return;
  if (typeof type === &#x27;string&#x27;) {
    type = otTypes[type];
    if (!type) return &#x22;Type not found&#x22;;
  }

  if (opData.op != null &#x26;&#x26; !type.transformCursor) return;
  if (opData.create) return; // Nothing to do!

  for (var id in p.data) {
    var d = p.data[id];
    if (d._cursor != null) {
      if (opData.op) {
        d._cursor = type.transformCursor(d._cursor, opData.op, id === opData.src);
      } else if (opData.del) {
        delete d._cursor;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.redisDriver" id="apidoc.module.share.db.redisDriver">module share.db.redisDriver</a></h1>


    <h2>
        <a href="#apidoc.element.share.db.redisDriver.redisDriver" id="apidoc.element.share.db.redisDriver.redisDriver">
        function <span class="apidocSignatureSpan">share.db.</span>redisDriver
        <span class="apidocSignatureSpan">(oplog, client, observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RedisDriver(oplog, client, observer) {
  if (!(this instanceof RedisDriver)) return new RedisDriver(oplog, client, observer);

  // Redis is used for atomic version incrementing, as an operation cache and for pubsub.
  this.redis = client || redisLib.createClient();

  // Persistant oplog.
  this.oplog = oplog;
  if (!oplog.writeOp || !oplog.getVersion || !oplog.getOps) {
    throw new Error(&#x27;Missing or invalid operation log&#x27;);
  }

  // Redis doesn&#x27;t allow the same connection to both listen to channels and do
  // operations. We make an extra redis connection for the streams.
  this.redisObserver = observer;
  if (!this.redisObserver) {
    // We can&#x27;t copy the selected db, but pubsub messages aren&#x27;t namespaced to their db anyway.
    // port and host are stored inside connectionOption object in redis &#x3e;= 0.12. previously they
    // were stored directly on the redis client itself.
    var port = this.redis.connectionOption ? this.redis.connectionOption.port : this.redis.port;
    var host = this.redis.connectionOption ? this.redis.connectionOption.host : this.redis.host;
    this.redisObserver = redisLib.createClient(this.redis.options, port, host);
    if (this.redis.auth_path) this.redisObserver.auth(this.redis.auth_pass);
    this.redisObserverCreated = true;
  }

  var self = this;
  this.redisObserver.on(&#x27;message&#x27;, function(channel, msg) {
    if (self.sdc) self.sdc.increment(&#x27;livedb.redis.message&#x27;);

    var data = JSON.parse(msg);

    var channelStreams = self.streams[channel];
    if (channelStreams) {
      for (var id in channelStreams) {
        channelStreams[id].pushOp(data);
      }
    }
    self.subscribers.emit(channel, channel, data);
  });

  // Emitter for channel messages. Event is the prefixed channel name. Listener is
  // called with (prefixed channel, msg)
  // TODO: This is only being used by the dirty queue now. It could probably
  // be removed and replaced with a simple map that would have less overhead
  this.subscribers = new EventEmitter();
  // Surpress max listener warnings
  this.subscribers.setMaxListeners(0);

  // For keeping track of streams
  this.nextStreamId = 0;
  this.numStreams = 0;
  // Maps channel -&#x3e; id -&#x3e; stream
  this.streams = {};

  // State for tracking subscriptions. We track this.subscribed separately from
  // the streams, since the stream gets added synchronously, and the subscribe
  // isn&#x27;t complete until the callback returns from Redis
  // Maps channel -&#x3e; true
  this.subscribed = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#redis.flushdb()

redisClient1 = redis.createClient(6379, &#x27;localhost&#x27;);
redisClient2 = redis.createClient(6379, &#x27;localhost&#x27;);

livedbLib = require &#x27;livedb&#x27;
memorydb  = livedbLib.memory()
driver = livedbLib.<span class="apidocCodeKeywordSpan">redisDriver</span>(memorydb, redisClient1, redisClient2);
livedb = livedbLib.client(db: memorydb, driver:driver)
livedb.redis = redisClient1
livedb.db = memorydb

shareServer = require &#x27;../../lib/server&#x27;
shareServer.createClient(backend: livedb)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.db.redisDriver.prototype" id="apidoc.module.share.db.redisDriver.prototype">module share.db.redisDriver.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._checkForLeaks" id="apidoc.element.share.db.redisDriver.prototype._checkForLeaks">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_checkForLeaks
        <span class="apidocSignatureSpan">(allowSubscriptions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkForLeaks = function (allowSubscriptions, callback) {
  if (!allowSubscriptions &#x26;&#x26; this.numStreams) {
    throw Error(&#x27;Leak detected - still &#x27; + this.numStreams + &#x27; outstanding subscriptions&#x27;);
  }

  if (Object.keys(this.streams).length !== this.numStreams) {
    console.error(&#x27;numStreams:&#x27;, this.numStreams, &#x27;this.streams:&#x27;, this.streams);
    throw Error(&#x27;this.numStreams does not match this.streams&#x27;);
  }

  // We should also check the streams we&#x27;re actually subscribed to on the redis observer.
  if (callback) callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._createStream" id="apidoc.element.share.db.redisDriver.prototype._createStream">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_createStream
        <span class="apidocSignatureSpan">(channel, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createStream = function (channel, version) {
  var stream = new util.OpStream(version);
  var self = this;
  stream.once(&#x27;close&#x27;, function() {
    self._removeStream(channel, stream);
  });

  this.numStreams++;
  if (this.sdc) this.sdc.gauge(&#x27;livedb.streams&#x27;, this.numStreams);

  var map = this.streams[channel] || (this.streams[channel] = {});
  stream.id = this.nextStreamId++;
  map[stream.id] = stream;

  return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._finishBulkSubscribe" id="apidoc.element.share.db.redisDriver.prototype._finishBulkSubscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_finishBulkSubscribe
        <span class="apidocSignatureSpan">(streams, requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finishBulkSubscribe = function (streams, requests, callback) {
  this.bulkGetOpsSince(requests, function(err, ops) {
    if (err) {
      destroyBulkStreams(streams);
      return callback(err);
    }
    for (var cName in requests) {
      var docs = requests[cName];
      for (var docName in docs) {
        var version = docs[docName];
        var stream = streams[cName][docName];
        stream.pack(version, ops[cName][docName]);
      }
    }
    callback(null, streams);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._finishSubscribe" id="apidoc.element.share.db.redisDriver.prototype._finishSubscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_finishSubscribe
        <span class="apidocSignatureSpan">(stream, cName, docName, version, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finishSubscribe = function (stream, cName, docName, version, callback) {
  this.getOps(cName, docName, version, null, function(err, ops) {
    if (err) {
      stream.destroy();
      return callback(err);
    }
    stream.pack(version, ops);
    callback(null, stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._getCollectionChannel" id="apidoc.element.share.db.redisDriver.prototype._getCollectionChannel">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_getCollectionChannel
        <span class="apidocSignatureSpan">(cName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getCollectionChannel = function (cName) {
  return this._prefixChannel(cName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._getDocChannel" id="apidoc.element.share.db.redisDriver.prototype._getDocChannel">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_getDocChannel
        <span class="apidocSignatureSpan">(cName, docName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getDocChannel = function (cName, docName) {
  return this._prefixChannel(cName + &#x27;.&#x27; + docName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._oplogGetOps" id="apidoc.element.share.db.redisDriver.prototype._oplogGetOps">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_oplogGetOps
        <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_oplogGetOps = function (cName, docName, from, to, callback) {
  if (to != null &#x26;&#x26; to &#x3c;= from) return callback(null, []);

  var start = Date.now();
  var self = this;
  this.oplog.getOps(cName, docName, from, to, function(err, ops) {
    if (err) return callback(err);
    if (ops.length &#x26;&#x26; ops[0].v !== from) {
      var err = &#x27;Oplog missing requested op: &#x27; + cName + &#x27; &#x27; + docName +
        &#x27; From: &#x27; + from + &#x27; To: &#x27; + to + &#x27; First oplog version: &#x27; + ops[0].v;
      return callback(err);
    }

    for (var i = 0; i &#x3c; ops.length; i++) {
      ops[i].v = from++;
    }

    if (self.sdc) self.sdc.timing(&#x27;livedb.db.getOps&#x27;, Date.now() - start);
    callback(null, ops);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._prefixChannel" id="apidoc.element.share.db.redisDriver.prototype._prefixChannel">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_prefixChannel
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_prefixChannel = function (channel) {
  return (this.redis.selected_db || 0) + &#x27; &#x27; + channel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisCacheVersion" id="apidoc.element.share.db.redisDriver.prototype._redisCacheVersion">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisCacheVersion
        <span class="apidocSignatureSpan">(cName, docName, v, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisCacheVersion = function (cName, docName, v, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.redis.cacheVersion&#x27;);
  var self = this;

  // At some point it&#x27;ll be worth caching the snapshot in redis as well and
  // checking performance.
  this.redis.setnx(getVersionKey(cName, docName), v, function(err, didSet) {
    if (err || !didSet) return callback ? callback(err) : null;

    // Just in case. The oplog shouldn&#x27;t be in redis if the version isn&#x27;t in
    // redis, but whatever.
    self._redisSetExpire(cName, docName, v, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisGetOps" id="apidoc.element.share.db.redisDriver.prototype._redisGetOps">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisGetOps
        <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisGetOps = function (cName, docName, from, to, callback) {
  // TODO: Make this a timing request.
  if (this.sdc) this.sdc.increment(&#x27;livedb.redis.getOps&#x27;);
  if (to === null) to = -1;

  if (to &#x3e;= 0) {
    // Early abort if the range is flat.
    if (from &#x3e;= to || to === 0) return callback(null, [], null);
    to--;
  }
  //console.log(&#x27;redisGetOps&#x27;, from, to);
  var self = this;

  this.redis.eval(
    getOpsCode,
    2,
    getVersionKey(cName, docName),
    getOpLogKey(cName, docName),
    from,
    to
  , function(err, result) {
    if (err) return callback(err);
    if (result === null) return callback(null, [], null);  // No data in redis. Punt to the persistant oplog.

    // Version of the document is at the end of the results list.
    var docV = result.pop();
    var ops = processRedisOps(docV, to, result);
    callback(null, ops, docV);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisSetExpire" id="apidoc.element.share.db.redisDriver.prototype._redisSetExpire">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSetExpire
        <span class="apidocSignatureSpan">(cName, docName, v, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisSetExpire = function (cName, docName, v, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.redis.setExpire&#x27;);
  this.redis.eval(
    setExpireCode,
    2,
    getVersionKey(cName, docName),
    getOpLogKey(cName, docName),
    v,
    callback || doNothing); // We need to send a callback here to work around a bug in node-redis 0.9
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisSubmitScript" id="apidoc.element.share.db.redisDriver.prototype._redisSubmitScript">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSubmitScript
        <span class="apidocSignatureSpan">(cName, docName, opData, dirtyData, docVersion, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisSubmitScript = function (cName, docName, opData, dirtyData, docVersion, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.redis.submit&#x27;);

  // Sadly, because of the dirty data needing to edit a handful of keys, we need
  // to construct the arguments list here programatically.

  var args = [
    submitCode,
    // num keys
    2,
    // KEYS
    getVersionKey(cName, docName),
    getOpLogKey(cName, docName)
  ];

  if (dirtyData) {
    for (var list in dirtyData) {
      args.push(getDirtyListKey(list));
      args[1]++; // num keys
    }
  }

  // ARGV
  args.push.apply(args, [
    opData.v,
    JSON.stringify(logEntryForData(opData)), // oplog entry
    docVersion
  ]);

  if (dirtyData) {
    for (var list in dirtyData) {
      args.push(JSON.stringify(dirtyData[list]));
    }
  }

  this.redis.eval(args, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisSubscribe" id="apidoc.element.share.db.redisDriver.prototype._redisSubscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisSubscribe
        <span class="apidocSignatureSpan">(channel, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisSubscribe = function (channel, callback) {
  var self = this;
  this.redisObserver.subscribe(channel, function(err) {
    if (err) return callback(err);
    self.subscribed[channel] = true;
    callback();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._redisUnsubscribe" id="apidoc.element.share.db.redisDriver.prototype._redisUnsubscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_redisUnsubscribe
        <span class="apidocSignatureSpan">(channel, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisUnsubscribe = function (channel, callback) {
  // Synchronously clear subscribed state, since we&#x27;ll actually be unsubscribed
  // at some point in the future, but it will be before the callback. If
  // subscribe is called in this period, we want to send a subscription message
  // and wait for it to complete before we can count on being subscribed again
  delete this.subscribed[channel];
  // Send the unsubscribe message to Redis
  this.redisObserver.unsubscribe(channel, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._removeStream" id="apidoc.element.share.db.redisDriver.prototype._removeStream">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_removeStream
        <span class="apidocSignatureSpan">(channel, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_removeStream = function (channel, stream) {
  var map = this.streams[channel];
  if (!map) return;

  this.numStreams--;
  if (this.sdc) this.sdc.gauge(&#x27;livedb.streams&#x27;, this.numStreams);

  delete map[stream.id];

  // Cleanup if this was the last subscribed stream for the channel
  if (util.hasKeys(map)) return;
  delete this.streams[channel];
  this._redisUnsubscribe(channel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype._writeOpToLog" id="apidoc.element.share.db.redisDriver.prototype._writeOpToLog">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>_writeOpToLog
        <span class="apidocSignatureSpan">(cName, docName, opData, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_writeOpToLog = function (cName, docName, opData, callback) {
  // Shallow copy the important fields from opData
  var entry = logEntryForData(opData);
  entry.v = opData.v; // The oplog API needs the version too.

  var self = this;
  if (this.sdc) this.sdc.increment(&#x27;livedb.db.getVersion&#x27;);
  this.oplog.getVersion(cName, docName, function(err, version) {
    if (err) return callback(err);
    // Its possible (though unlikely) that ops will be missing from the oplog if the redis script
    // succeeds but the process crashes before the persistant oplog is given the new operations. In
    // this case, backfill the persistant oplog with the data in redis.
    if (version &#x3c; opData.v) {
      //console.log(&#x27;populating oplog&#x27;, version, opData.v);
      self._redisGetOps(cName, docName, version, opData.v, function(err, results, docV) {
        if (err) return callback(err);

        results.push(entry);

        var next = function() {
          if (results.length === 0) return callback();

          if (self.sdc) self.sdc.increment(&#x27;livedb.db.writeOp&#x27;);
          self.oplog.writeOp(cName, docName, results.shift(), function(err) {
            if (err) return callback(err);
            // In a nexttick to prevent stack overflows with syncronous oplog
            // implementations
            process.nextTick(next);
          });
        };
        next();
      });
    } else {
      self.oplog.writeOp(cName, docName, entry, callback);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.atomicSubmit" id="apidoc.element.share.db.redisDriver.prototype.atomicSubmit">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>atomicSubmit
        <span class="apidocSignatureSpan">(cName, docName, opData, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atomicSubmit = function (cName, docName, opData, options, callback) {
  if (!callback) throw &#x27;Callback missing in atomicSubmit&#x27;
  var self = this;

  // The passed callback function expects (err) where err == &#x27;Transform needed&#x27;
  // if we need to transform before applying. The callback passed to
  // _redisSubmitScript takes (err, redisResult). redisResult is an error string
  // passed back from redis (although to make things more complicated, some
  // error strings are actually fine and simply mean redis is missing data).
  //
  // Specifically, result is one of the following:
  //
  // &#x27;Missing data&#x27;: Redis is not populated for this document. Repopulate and
  //      retry.
  // &#x27;Version from the future&#x27;: Probably an error. Data in redis has been
  //      dumped. Reload from oplog redis and retry.
  // &#x27;Op already submitted&#x27;: Return this error back to the user.
  // &#x27;Transform needed&#x27;: Operation is old. Transform and retry. Retry handled in
  //      livedb proper.
  var callbackWrapper = function(err, result) {
    if (err) return callback(err); // Error communicating with redis
    if (result) return callback(result);

    self._writeOpToLog(cName, docName, opData, callback)
  };

  var dirtyData = options &#x26;&#x26; options.dirtyData;
  this._redisSubmitScript(cName, docName, opData, dirtyData, null, function(err, result) {
    if (err) return callback(err);

    if (result === &#x27;Missing data&#x27; || result === &#x27;Version from the future&#x27;) {
      if (self.sdc) self.sdc.increment(&#x27;livedb.redis.cacheMiss&#x27;);
      // The data in redis has been dumped. Fill redis with data from the oplog and retry.
      self.oplog.getVersion(cName, docName, function(err, version) {
        if (err) return callback(err);

        if (version &#x3c; opData.v) {
          // The oplog is basically corrupted - the snapshot database is
          // further in the future than the oplog.
          //
          // In this case, we could write a no-op ramp to the snapshot version,
          // followed by a delete &#x26; a create to fill in the missing ops.
          var err = &#x27;Missing oplog data: &#x27; + cName + &#x27; &#x27; + docName +
            &#x27; Version: &#x27; + version + &#x27; Op version: &#x27; + opData.v;
          return callback(err);
        }
        self._redisSubmitScript(cName, docName, opData, dirtyData, version, callbackWrapper);
      });
    } else {
      if (self.sdc) self.sdc.increment(&#x27;livedb.redis.cacheHit&#x27;);
      callbackWrapper(null, result);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.bulkGetOpsSince" id="apidoc.element.share.db.redisDriver.prototype.bulkGetOpsSince">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>bulkGetOpsSince
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkGetOpsSince = function (requests, callback) {
  var start = Date.now();
  // Not considering the case where redis has _some_ data but not all of it.
  // The script will just return all the data since the specified version ([]
  // if we know there&#x27;s no ops) or nil if we don&#x27;t have enough information to
  // know.

  // First I&#x27;ll unpack all the things I need to know into these arrays. The
  // indexes all line up. I could use one array of object literals, but I
  // *think* this is faster, and I need the versionKeys, opLogKeys and froms
  // in separate arrays anyway to pass to redis.
  var cNames = [];
  var docNames = [];

  // Its kind of gross to do it like this, but I don&#x27;t see any other good
  // options. We can&#x27;t pass JS arrays directly into lua tables in the script,
  // so the arguments list will have to contain a splay of all the values.
  var redisArgs = [bulkGetOpsSinceCode, 0]; // 0 is a sentinal to be replaced with the number of keys

  var froms = [];

  for (var cName in requests) {
    var data = requests[cName];
    for (var docName in data) {
      var version = data[docName];

      cNames.push(cName);
      docNames.push(docName);

      redisArgs.push(getVersionKey(cName, docName));
      redisArgs.push(getOpLogKey(cName, docName));
      froms.push(version);
    }
  }

  // The froms have to come after the version keys and oplog keys because its
  // an argument list rather than a key list.
  redisArgs[1] = redisArgs.length - 2;
  redisArgs = redisArgs.concat(froms);

  var self = this;

  if (this.sdc) this.sdc.increment(&#x27;livedb.redis.bulkGetOpsSince&#x27;);

  this.redis.eval(redisArgs, function(err, redisResults) {
    if (err) return callback(err);
    if (redisResults.length !== cNames.length) return callback(&#x27;Invalid data from redis&#x27;);

    var results = {};
    var pending = 1;
    var done = function() {
      pending--;
      if (pending === 0) {
        if (self.sdc) self.sdc.timing(&#x27;livedb.bulkGetOpsSince&#x27;, Date.now() - start);
        callback(null, results);
      }
    };

    for (var i = 0; i &#x3c; redisResults.length; i++) {
      var result = redisResults[i];

      var cName = cNames[i];
      var docName = docNames[i];
      var from = froms[i];

      if (results[cName] == null) results[cName] = {};

      if (result === 0) { // sentinal value to mean we should go to the oplog.
        pending++;
        (function(cName, docName, from) {
          // We could have a bulkGetOps in the oplog too, but because we cache
          // anything missing in redis, I&#x27;m not super worried about the extra
          // calls here.
          self._oplogGetOps(cName, docName, from, null, function(err, ops) {
            if (err) return callback(err);
            results[cName][docName] = ops;

            // I&#x27;m going to do a sneaky cache here if its not in redis.
            self.oplog.getVersion(cName, docName, function(err, version) {
              if (err) return;
              self._redisCacheVersion(cName, docName, version);
            });
            done();
          });
        })(cName, docName, from);

      } else {
        var v = from;
        // The ops are missing a version field. We&#x27;ll add it back here. This
        // logic is repeated in processRedisOps, and should be pulled out into
        // a separate function.
        var ops = new Array(result.length);
        for (var j = 0; j &#x3c; result.length; j++) {
          var op = JSON.parse(result[j]);
          op.v = v++;
          ops[j] = op;
        }
        results[cName][docName] = ops;
      }
    }
    done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.bulkSubscribe" id="apidoc.element.share.db.redisDriver.prototype.bulkSubscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>bulkSubscribe
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkSubscribe = function (requests, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.subscribe.bulk&#x27;);

  // List of Redis channels to subscribe (if any)
  var channels = [];
  // Map from cName -&#x3e; docName -&#x3e; stream
  var streams = {};

  for (var cName in requests) {
    var docs = requests[cName];
    var collectionStreams = streams[cName] = {};
    for (var docName in docs) {
      var channel = this._getDocChannel(cName, docName);
      if (!this.subscribed[channel]) {
        channels.push(channel);
      }
      var version = docs[docName];
      collectionStreams[docName] = this._createStream(channel, version);
    }
  }

  if (!channels.length) {
    this._finishBulkSubscribe(streams, requests, callback);
    return;
  }
  // Redis supports sending multiple channels to subscribe in one command,
  // but the node client doesn&#x27;t handle replies correctly.
  // See https://github.com/mranney/node_redis/issues/577
  var self = this;
  async.each(channels, function(channel, eachCallback) {
    self._redisSubscribe(channel, eachCallback);
  }, function(err) {
    if (err) {
      destroyBulkStreams(streams);
      return callback(err);
    }
    self._finishBulkSubscribe(streams, requests, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Set the version that we&#x27;ll subscribe to
  request[cName][docName] = snapshot.v;
  // Set the snapshot in the response
  response[cName][docName] = snapshot;
}
    }

    agent.<span class="apidocCodeKeywordSpan">bulkSubscribe</span>(request, function(err, streams) {
if (err) {
  self._cancelBulk(request);
  return callback(err);
}

for (var cName in streams) {
  for (var docName in streams[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.consumeDirtyData" id="apidoc.element.share.db.redisDriver.prototype.consumeDirtyData">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>consumeDirtyData
        <span class="apidocSignatureSpan">(listName, options, consumeFn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consumeDirtyData = function (listName, options, consumeFn, callback) {
  var limit = options.limit || 1024;
  var wait = options.wait;
  var key = getDirtyListKey(listName);
  var self = this;
  this.redis.lrange(key, 0, limit - 1, function(err, data) {
    if (err) return callback(err);

    var num = data.length;
    if (num === 0) {
      if (!wait) return callback();

      // In this case, we&#x27;re waiting for data and there&#x27;s no data to be read.
      // We&#x27;ll subscribe to the dirty data channel and retry when there&#x27;s data.
      // I could use some of the fancy subscribe functions below, but we&#x27;re
      // guaranteed that we won&#x27;t subscribe to the same channel multiple times
      // anyway, so I can subscribe directly.
      var retried = false;

      self.redisObserver.subscribe(key, function(err) {
        if (err) return callback(err);

        self.subscribers.once(key, function() {
          if (retried) return; else retried = true;
          self.redisObserver.unsubscribe(key, function() {
            self.consumeDirtyData(listName, options, consumeFn, callback);
          });
        });

        // Ok, between when we called lrange and now, there might actually be
        // data added (*tear*).
        self.redis.exists(key, function(err, result) {
          if (err) return callback(err);
          if (result) {
            if (retried) return; else retried = true;
            self.subscribers.removeAllListeners(key);
            self.redisObserver.unsubscribe(key, function() {
              self.consumeDirtyData(listName, options, consumeFn, callback);
            });
          }
        });
      });
      return;
    }

    for (var i = 0; i &#x3c; data.length; i++) {
      data[i] = JSON.parse(data[i]);
    }
    consumeFn(data, function(err) {
      // Should we do anything else here?
      if (err) return callback(err);

      self.redis.ltrim(key, num, -1);
      callback();
    })
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.destroy" id="apidoc.element.share.db.redisDriver.prototype.destroy">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  if (this.redisObserverCreated) this.redisObserver.quit();

  for (var channel in this.streams) {
    var map = this.streams[channel];
    for (var id in map) {
      map[id].destroy();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Document objects store your actual data in the client. They can be modified
syncronously and they can automatically sync their data with the server.
Document objects can be modified offline - they will send data to the server
when the client reconnects.

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.<span class="apidocCodeKeywordSpan">destroy</span>()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.getOps" id="apidoc.element.share.db.redisDriver.prototype.getOps">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>getOps
        <span class="apidocSignatureSpan">(cName, docName, from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOps = function (cName, docName, from, to, callback) {
  //console.log(&#x27;getOps&#x27;, from, to)
  var self = this;
  // First try to get the ops from redis.
  this._redisGetOps(cName, docName, from, to, function(err, ops, v) {
    // There are sort of three cases here:
    //
    // - Redis has no data at all: v is null
    // - Redis has some of the ops, but not all of them. v is set, and ops
    //   might not contain everything we want.
    // - Redis has all of the operations we need
    if (err) return callback(err);

    // What should we do in this case, when redis returns ops but is missing
    // ops at the end of the requested range? It shouldn&#x27;t be possible, but
    // we should probably detect that case at least.
    // if (to !== null &#x26;&#x26; ops[ops.length - 1].v !== to)

    if ((v != null &#x26;&#x26; from &#x3e;= v) || (ops.length &#x3e; 0 &#x26;&#x26; ops[0].v === from)) {
      // redis has all the ops we wanted.
      if (self.sdc) self.sdc.increment(&#x27;livedb.getOps.cacheHit&#x27;);
      callback(null, ops, v);
    } else if (ops.length &#x3e; 0) {
      // The ops we got from redis are at the end of the list of ops we need.
      if (self.sdc) self.sdc.increment(&#x27;livedb.getOps.cacheMissPartial&#x27;);
      self._oplogGetOps(cName, docName, from, ops[0].v, function(err, firstOps) {
        if (err)
          callback(err);
        else
          callback(null, firstOps.concat(ops), v);
      });
    } else {
      if (self.sdc) self.sdc.increment(&#x27;livedb.getOps.cacheMiss&#x27;);
      // No ops in redis. Just get all the ops from the oplog.
      self._oplogGetOps(cName, docName, from, to, function(err, ops) {
        if (err) return callback(err);

        // I&#x27;m going to do a sneaky cache here if its not in redis.
        if (v == null &#x26;&#x26; to == null) {
          self.oplog.getVersion(cName, docName, function(err, version) {
            if (err) return;
            self._redisCacheVersion(cName, docName, version);
          });
        }
        callback(null, ops, v); // v could be null.
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var from = 0, to = null;

  var query = url.parse(req.url, true).query;

  if (query &#x26;&#x26; query.from) from = parseInt(query.from)|0;
  if (query &#x26;&#x26; query.to) to = parseInt(query.to)|0;

  req._shareAgent.<span class="apidocCodeKeywordSpan">getOps</span>(req.params.cName, req.params.docName, from, to, function(err
, ops) {
    if (err)
      sendError(res, err);
    else
      sendJSON(res, ops);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.postSubmit" id="apidoc.element.share.db.redisDriver.prototype.postSubmit">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>postSubmit
        <span class="apidocSignatureSpan">(cName, docName, opData, snapshot, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postSubmit = function (cName, docName, opData, snapshot, options) {
  opData.collection = cName;
  opData.docName = docName;

  var msg = JSON.stringify(opData);
  var docChannel = this._getDocChannel(cName, docName);
  this.redis.publish(docChannel, msg);

  // Publish the change to the collection name (not the doc name!) for queries.
  if (options &#x26;&#x26; !options.suppressCollectionPublish) {
    var collectionChannel = this._getCollectionChannel(cName);
    this.redis.publish(collectionChannel, msg);
  }

  // Set the TTL on the document now that it has been written to the oplog.
  this._redisSetExpire(cName, docName, opData.v, function(err) {
    // This shouldn&#x27;t happen, but its non-fatal. It just means ops won&#x27;t get flushed from redis.
    if (err) console.trace(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.subscribe" id="apidoc.element.share.db.redisDriver.prototype.subscribe">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(cName, docName, version, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (cName, docName, version, options, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.subscribe.doc&#x27;);

  // Subscribe to the stream first so we don&#x27;t miss out on any operations
  // while we&#x27;re getting the history
  var channel = this._getDocChannel(cName, docName);
  var stream = this._createStream(channel, version);

  if (this.subscribed[channel]) {
    this._finishSubscribe(stream, cName, docName, version, callback);
    return;
  }
  var self = this;
  this._redisSubscribe(channel, function(err) {
    if (err) {
      stream.destroy();
      return callback(err);
    }
    self._finishSubscribe(stream, cName, docName, version, callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.<span class="apidocCodeKeywordSpan">subscribe</span>(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.db.redisDriver.prototype.subscribeCollection" id="apidoc.element.share.db.redisDriver.prototype.subscribeCollection">
        function <span class="apidocSignatureSpan">share.db.redisDriver.prototype.</span>subscribeCollection
        <span class="apidocSignatureSpan">(cName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeCollection = function (cName, callback) {
  if (this.sdc) this.sdc.increment(&#x27;livedb.subscribe.collection&#x27;);

  // From here on, we need to call stream.destroy() if there are errors
  var channel = this._getCollectionChannel(cName);
  var stream = this._createStream(channel);

  if (this.subscribed[channel]) {
    process.nextTick(function() {
      callback(null, stream);
    });
    return;
  }
  var self = this;
  this._redisSubscribe(channel, function(err) {
    if (err) {
      stream.destroy();
      return callback(err);
    }
    callback(null, stream);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.emitter" id="apidoc.module.share.emitter">module share.emitter</a></h1>


    <h2>
        <a href="#apidoc.element.share.emitter.EventEmitter" id="apidoc.element.share.emitter.EventEmitter">
        function <span class="apidocSignatureSpan">share.emitter.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.emitter.mixin" id="apidoc.element.share.emitter.mixin">
        function <span class="apidocSignatureSpan">share.emitter.</span>mixin
        <span class="apidocSignatureSpan">(Constructor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mixin(Constructor) {
  for (var key in EventEmitter.prototype) {
    Constructor.prototype[key] = EventEmitter.prototype[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 // I&#x27;ll store the most recent 100 messages so when errors occur we can see
 // what happened.
 this.messageBuffer = [];

 this.bindToSocket(socket);
}
emitter.<span class="apidocCodeKeywordSpan">mixin</span>(Connection);


/**
* Use socket to communicate with server
*
* Socket is an object that can handle the websocket protocol. This method
* installs the onopen, onclose, onmessage and onerror handlers on the socket to
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.query" id="apidoc.module.share.query">module share.query</a></h1>


    <h2>
        <a href="#apidoc.element.share.query.Query" id="apidoc.element.share.query.Query">
        function <span class="apidocSignatureSpan">share.query.</span>Query
        <span class="apidocSignatureSpan">(type, connection, id, collection, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Query = function (type, connection, id, collection, query, options, callback) {
  emitter.EventEmitter.call(this);

  // &#x27;fetch&#x27; or &#x27;sub&#x27;
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {&#x22;data.x&#x22;:5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, &#x27;fetch&#x27; or &#x27;sub&#x27;.
  if (this.docMode === &#x27;subscribe&#x27;) this.docMode = &#x27;sub&#x27;;

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query&#x27;s properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn&#x27;t defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won&#x27;t be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.server" id="apidoc.module.share.server">module share.server</a></h1>


    <h2>
        <a href="#apidoc.element.share.server.createClient" id="apidoc.element.share.server.createClient">
        function <span class="apidocSignatureSpan">share.server.</span>createClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createClient = function (options) {
  return new ShareInstance(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To create a ShareJS server instance:

```javascript
var livedb = require(&#x27;livedb&#x27;);
var sharejs = require(&#x27;share&#x27;);

var backend = livedb.client(livedb.memory());
var share = require(&#x27;share&#x27;).server.<span class="apidocCodeKeywordSpan">createClient</span>({backend: backend});
```

The method is called `createClient` because its sort of a client of the
database... its a weird name, just roll with it.

The sharejs server instance has 3 methods you might care about:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.session" id="apidoc.module.share.session">module share.session</a></h1>


    <h2>
        <a href="#apidoc.element.share.session.session" id="apidoc.element.share.session.session">
        function <span class="apidocSignatureSpan">share.</span>session
        <span class="apidocSignatureSpan">(instance, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Session(instance, stream) {
  // The stream passed in should be a nodejs 0.10-style stream.
  this.stream = stream;

  // This is the user agent through which a connecting client acts.  The agent
  // is responsible for making sure client requests are properly authorized,
  // and metadata is kept up to date.
  this.agent = instance.createAgent(stream);
  this.agent.session = this;

  // We need to track which documents are subscribed by the client. This is a
  // map of collection name -&#x3e; {doc name: stream || true || false}
  this.collections = {};

  // Map from query ID -&#x3e; emitter.
  this.queries = {};

  // Subscriptions care about the stream being destroyed. We end up with a
  // listener per subscribed document for the client, which can be a lot.
  stream.setMaxListeners(0);

  // We need to track this manually to make sure we don&#x27;t reply to messages
  // after the stream was closed. There&#x27;s no built-in way to ask a stream
  // whether its actually still open.
  this.closed = false;

  stream.once(&#x27;end&#x27;, this._cleanup.bind(this));

  // Initialize the remote client by sending it its session Id.
  this._send({a:&#x27;init&#x27;, protocol:0, id:this.agent.sessionId});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.session.prototype" id="apidoc.module.share.session.prototype">module share.session.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.session.prototype._cancelBulk" id="apidoc.element.share.session.prototype._cancelBulk">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_cancelBulk
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cancelBulk = function (request) {
  // Cancel the subscribed state on the documents.
  for (var cName in request) {
    var docs = request[cName];
    for (var docName in docs) {
      this._setSubscribed(cName, docName, false);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // Next we do a bulkFetch on all the items that need a fetchin&#x27;. If no
  // documents need a fetch, this returns into the callback immediately.
  agent.bulkFetch(needFetch, function(err, snapshots) {
if (err) {
  // For now, just abort the whole bundle on error. We could be more
  // neuanced about this, but I&#x27;ll wait for a use case.
  self.<span class="apidocCodeKeywordSpan">_cancelBulk</span>(request);
  return callback(err);
}

for (var cName in snapshots) {
  for (var docName in snapshots[cName]) {
    var snapshot = snapshots[cName][docName];
    // Set the version that we&#x27;ll subscribe to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._checkRequest" id="apidoc.element.share.session.prototype._checkRequest">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_checkRequest
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkRequest = function (req) {
  if (req.a === &#x27;qsub&#x27; || req.a === &#x27;qfetch&#x27; || req.a === &#x27;qunsub&#x27;) {
    // Query messages need an ID property.
    if (typeof req.id !== &#x27;number&#x27;) return &#x27;Missing query ID&#x27;;
  } else if (req.a === &#x27;op&#x27; || req.a === &#x27;sub&#x27; || req.a === &#x27;unsub&#x27; || req.a === &#x27;fetch&#x27;) {
    // Doc-based request.
    if (req.c != null &#x26;&#x26; typeof req.c !== &#x27;string&#x27;) return &#x27;Invalid collection&#x27;;
    if (req.d != null &#x26;&#x26; typeof req.d !== &#x27;string&#x27;) return &#x27;Invalid docName&#x27;;

    if (req.a === &#x27;op&#x27;) {
      if (req.v != null &#x26;&#x26; (typeof req.v !== &#x27;number&#x27; || req.v &#x3c; 0)) return &#x27;Invalid version&#x27;;
    }
  } else if (req.a === &#x27;bs&#x27;) {
    // Bulk subscribe
    if (typeof req.s !== &#x27;object&#x27;) return &#x27;Invalid bulk subscribe data&#x27;;
  } else {
    return &#x27;Invalid action&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return messages;
};

// Handle an incoming message from the client. This is the actual guts of session.js.
Session.prototype._handleMessage = function(req, callback) {
// First some checks of the incoming request. Error will be set to a value if a problem is found.
var error;
if ((error = this.<span class="apidocCodeKeywordSpan">_checkRequest</span>(req))) {
  console.warn(&#x27;Warning: Invalid request from &#x27;, this.agent.sessionId, req, &#x27;Error: &#x27;, error);
  return callback(error);
}

if (req.a === &#x27;qsub&#x27; || req.a === &#x27;qfetch&#x27; || req.a === &#x27;qunsub&#x27;) {
  // Query based request.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._cleanup" id="apidoc.element.share.session.prototype._cleanup">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanup = function () {
  if (this.closed) return
  this.closed = true;

  // Remove the pump listener
  this.stream.removeAllListeners(&#x27;readable&#x27;);

  // Clean up all the subscriptions.
  for (var c in this.collections) {
    for (var docName in this.collections[c]) {
      var value = this.collections[c][docName];
      // Value can be true, false or a stream. true means we&#x27;re in the
      // process of subscribing the client.
      if (typeof value === &#x27;object&#x27;) {
        destroyStream(value);
      }
      this.collections[c][docName] = false; // cancel the subscribe
    }
  }

  for (var id in this.queries) {
    var emitter = this.queries[id];
    emitter.destroy();
    delete this.queries[id];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._handleMessage" id="apidoc.element.share.session.prototype._handleMessage">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_handleMessage
        <span class="apidocSignatureSpan">(req, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleMessage = function (req, callback) {
  // First some checks of the incoming request. Error will be set to a value if a problem is found.
  var error;
  if ((error = this._checkRequest(req))) {
    console.warn(&#x27;Warning: Invalid request from &#x27;, this.agent.sessionId, req, &#x27;Error: &#x27;, error);
    return callback(error);
  }

  if (req.a === &#x27;qsub&#x27; || req.a === &#x27;qfetch&#x27; || req.a === &#x27;qunsub&#x27;) {
    // Query based request.

    // Queries have an ID to refer to the particular query in the client
    var qid = req.id;

    // The index that will handle the query request. For mongo queries, this is
    // simply the collection that contains the data.
    var index = req.c;

    // Options for liveDB.query.
    var qopts = {};

    if (req.o) {
      // Do we send back document snapshots for the results? Either &#x27;fetch&#x27; or &#x27;sub&#x27;.
      qopts.docMode = req.o.m;
      if (qopts.docMode != null &#x26;&#x26; qopts.docMode !== &#x27;fetch&#x27; &#x26;&#x26; qopts.docMode !== &#x27;sub&#x27;)
        return callback(&#x27;invalid query docmode: &#x27; + qopts.docMode);

      // The client tells us what versions it already has
      qopts.versions = req.o.vs;

      // Enables polling mode, which forces the query to be rerun on the whole
      // index, not just the edited document.
      qopts.poll = req.o.p;

      // Set the backend for the request (useful if you have a SOLR index or something)
      qopts.backend = req.o.b;
    }
  } else if (req.a !== &#x27;bs&#x27;) {
    var collection = req.c;
    var docName = req.d;
  }

  var self = this;
  var agent = this.agent;

  // Now process the actual message.
  switch (req.a) {
    case &#x27;fetch&#x27;:
      // Fetch request.
      if (req.v != null) {
        // It says fetch on the tin, but if a version is specified the client
        // actually wants me to fetch some ops.
        agent.getOps(collection, docName, req.v, null, function(err, results) {
          if (err) return callback(err);

          for (var i = 0; i &#x3c; results.length; i++) {
            self._sendOp(collection, docName, results[i]);
          }

          callback(null, {});
        });
      } else {
        // Fetch a snapshot.
        agent.fetch(collection, docName, function(err, data) {
          if (err) return callback(err);

          callback(null, {data: data});
        });
      }
      break;

    case &#x27;sub&#x27;:
      // Subscribe to a document. If the version is specified, we&#x27;ll catch the
      // client up by sending all ops since the specified version.
      //
      // If the version is not specified, the client doesn&#x27;t have a snapshot
      // yet. We&#x27;ll send them a snapshot at the most recent version and stream
      // operations from that version.
      this._subscribe(collection, docName, req.v, function(err, data) {
        if (err)
          callback(err);
        else
          callback(null, {data:data});
      });
      break;

    case &#x27;bs&#x27;:
      this.bulkSubscribe(req.s, function(err, response) {
        callback(err, err ? null : {s:response});
      });
      break;

    case &#x27;unsub&#x27;:
      // Unsubscribe from the specified document. This cancels the active
      // opstream or an inflight subscribing state
      this._setSubscribed(collection, docName, false);
      callback(null, {});
      break;

    case &#x27;op&#x27;:
      // Submit an operation.
      //
      // Shallow clone to get just the op data parts.
      var opData = {
        // src can be provided if it is not the same as the current session,
        // such as a resubmission after a reconnect, but it usually isn&#x27;t needed
        src: req.src || agent.sessionId,
        seq: req.seq,
        v: req.v
      };
      if (req.op) opData.op = req.op;
      if (req.create) opData.create = req.create;
      if (req.del) opData.del = req.del;

      // There&#x27;s nothing to put in here yet. We might end up with some stuff
      // from the client.
      var options = {};

      // Actually submit the op to the backend
      agent.submit(collection, docName, opData, options, function(err, v, ops) {
        // Occassional &#x27;Op already submitted&#x27; errors are expected to happen
        // as part of normal operatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
  req = JSON.parse(req);
} catch(e) {
  console.warn(&#x27;Client sent invalid JSON&#x27;, e.stack);
  self.close(e);
}
    }
    this.<span class="apidocCodeKeywordSpan">_handleMessage</span>(req, function(err, msg) {
if (err || msg) self._reply(req, err, msg);

// This is in a process.nextTick to avoid stack smashing attacks (since
// sometimes this callback function is called synchronously).
process.nextTick(function() {
  self.pump();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._isSubscribed" id="apidoc.element.share.session.prototype._isSubscribed">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_isSubscribed
        <span class="apidocSignatureSpan">(c, docName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isSubscribed = function (c, docName) {
  return this.collections[c] &#x26;&#x26; this.collections[c][docName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// The backend replies with any operations that the client is missing.
// If the client is subscribed to the document, it&#x27;ll get those
// operations through the regular subscription channel. If the client
// isn&#x27;t subscribed, we&#x27;ll send the ops with the response as if it was
// subscribed so the client catches up.
if (!self.<span class="apidocCodeKeywordSpan">_isSubscribed</span>(collection, docName)) {
  for (var i = 0; i &#x3c; ops.length; i++) {
    var op = ops[i];
    if (!op) {
      console.warn(&#x27;Null op ignored in agent.submit callback.&#x27;, collection, docName, opData, v, ops);
      continue;
    }
    self._sendOp(collection, docName, op);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._processQueryResults" id="apidoc.element.share.session.prototype._processQueryResults">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_processQueryResults
        <span class="apidocSignatureSpan">(collection, results, qopts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processQueryResults = function (collection, results, qopts) {
  var self = this;
  var messages = [];

  // Types are only put in the result set for the first result and every time the type changes.
  var lastType = null;
  results.forEach(function(r) {
    var docName = r.docName;

    var message = {c:collection, d:docName, v:r.v};
    messages.push(message);

    if (lastType !== r.type) {
      lastType = message.type = r.type;
    }

    if (qopts.docMode) {
      var atVersion = qopts.versions &#x26;&#x26; qopts.versions[collection] &#x26;&#x26; qopts.versions[collection][docName];
      // Only give the client snapshot data if the client requested it and they
      // don&#x27;t already have a copy of the document.
      if (atVersion == null) {
        message.data = r.data;
      } else if (r.v &#x3e; atVersion) {
        // We won&#x27;t put any op data into the response, but we&#x27;ll send some
        // normal ops to follow the query. This might not be the best idea - it
        // means that sometimes the query will say that a document matches
        // before you get the document&#x27;s updated data.
        self.agent.getOps(collection, docName, atVersion, -1, function(err, results) {
          if (err) {
            self._send({a:&#x27;fetch&#x27;, c:collection, d:docName, error:err});
            return;
          }
          for (var i = 0; i &#x3c; results.length; i++) {
            self._sendOp(collection, docName, results[i]);
          }
        });
      }
    }
  });

  return messages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Fetch the results of a query. This does not subscribe to the query or
  // anything, its just a once-off query fetch.
  agent.queryFetch(index, req.q, qopts, function(err, results, extra) {
    if (err) return callback(err);

    // If the query subscribes to documents, the callback isn&#x27;t called
    // until all the documents are subscribed.
    var data = self.<span class="apidocCodeKeywordSpan">_processQueryResults</span>(req.c, results, qopts);

    callback(null, {id:qid, data:data, extra:extra});
    //self._reply(req, null, {id:qid, data:results, extra:extra});
  });
  break;

case &#x27;qsub&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._reply" id="apidoc.element.share.session.prototype._reply">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_reply
        <span class="apidocSignatureSpan">(req, err, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_reply = function (req, err, msg) {
  if (err) {
    msg = {a:req.a, error:err};
  } else {
    if (!msg.a) msg.a = req.a;
  }

  if (req.c) msg.c = req.c; // collection
  if (req.d) msg.d = req.d; // docName
  if (req.id) msg.id = req.id;

  this._send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    req = JSON.parse(req);
  } catch(e) {
    console.warn(&#x27;Client sent invalid JSON&#x27;, e.stack);
    self.close(e);
  }
}
this._handleMessage(req, function(err, msg) {
  if (err || msg) self.<span class="apidocCodeKeywordSpan">_reply</span>(req, err, msg);

  // This is in a process.nextTick to avoid stack smashing attacks (since
  // sometimes this callback function is called synchronously).
  process.nextTick(function() {
    self.pump();
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._send" id="apidoc.element.share.session.prototype._send">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_send
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_send = function (msg) {
  // Quietly drop replies if the stream was closed
  if (this.closed) return;

  this.stream.write(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// after the stream was closed. There&#x27;s no built-in way to ask a stream
// whether its actually still open.
this.closed = false;

stream.once(&#x27;end&#x27;, this._cleanup.bind(this));

// Initialize the remote client by sending it its session Id.
this.<span class="apidocCodeKeywordSpan">_send</span>({a:&#x27;init&#x27;, protocol:0, id:this.agent.sessionId});
}

Session.prototype._cleanup = function() {
if (this.closed) return
this.closed = true;

// Remove the pump listener
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._sendOp" id="apidoc.element.share.session.prototype._sendOp">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_sendOp
        <span class="apidocSignatureSpan">(collection, docName, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendOp = function (collection, docName, data) {
  var msg = {
    a: &#x27;op&#x27;,
    c: collection,
    d: docName,
    v: data.v,
    src: data.src,
    seq: data.seq
  };

  // In theory, we only need to send the operation data if data.src !==
  // this.agent.sessionId. However, this doesn&#x27;t work with projections because
  // the client needs to see their own operations in the projected collection.
  //
  // I&#x27;d like to reinstate this optimization, but I can&#x27;t think of a good way to
  // do it while making projections work. For now, you get your own operations
  // back.
  if (data.op) msg.op = data.op;
  if (data.create) msg.create = data.create;
  if (data.del) msg.del = true;

  this._send(msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Our set was rejected and our stream was destroyed, so just return
if (previous) return;

var self = this;
// This should use the new streams API instead of the old one.
opstream.on(&#x27;data&#x27;, onData);
function onData(data) {
  self.<span class="apidocCodeKeywordSpan">_sendOp</span>(collection, docName, data);
};
opstream.once(&#x27;end&#x27;, function() {
  // Livedb has closed the op stream. What do we do here? Normally this
  // shouldn&#x27;t happen unless we&#x27;re cleaning up, so I&#x27;ll assume thats whats
  // happening now.
  self._setSubscribed(collection, docName, false);
  opstream.removeListener(&#x27;data&#x27;, onData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._setSubscribed" id="apidoc.element.share.session.prototype._setSubscribed">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_setSubscribed
        <span class="apidocSignatureSpan">(collection, docName, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setSubscribed = function (collection, docName, value) {
  var docs = this.collections[collection] || (this.collections[collection] = {});
  // Check to see if already subscribed
  var previous = docs[docName];
  if (typeof value === &#x27;object&#x27;) {
    if (previous !== true) {
      // The document has been unsubscribed or replaced with another stream
      // already. Either way, we destroy the new stream, since the existing
      // stream should have been subscribed the whole time. Possible I might be
      // missing some race condition and we might miss a message (nateps)
      destroyStream(value);
      return previous;
    }
  } else if (value === true) {
    // Reject replacing subscribed stream or subscribing state with
    // a new subscribing state
    if (previous) {
      // Return existing stream or subscribing state on failure
      return previous;
    }
  } else {
    // Unsubscribe
    if (typeof previous === &#x27;object&#x27;) {
      destroyStream(previous);
    }
  }
  // Set to new value
  docs[docName] = value;
  // Returns nothing on success
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Passes operation data received on opstream to the session stream via
 * _sendOp()
 */
Session.prototype._subscribeToStream = function(collection, docName, opstream) {
var previous = this.<span class="apidocCodeKeywordSpan">_setSubscribed</span>(collection, docName, opstream);
// Our set was rejected and our stream was destroyed, so just return
if (previous) return;

var self = this;
// This should use the new streams API instead of the old one.
opstream.on(&#x27;data&#x27;, onData);
function onData(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._subscribe" id="apidoc.element.share.session.prototype._subscribe">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(collection, docName, v, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (collection, docName, v, callback) {
  var self = this;
  this._setSubscribed(collection, docName, true);

  if (v != null) {
    // This logic is mirrored in _processQueryResults below. If you change
    // how it works, update that function too.
    // Yes, I know I&#x27;m a bad person.
    this.agent.subscribe(collection, docName, v, function(err, opstream) {
      if (err) {
        self._setSubscribed(collection, docName, false);
        return callback(err);
      }
      self._subscribeToStream(collection, docName, opstream);
      callback();
    });
  } else {
    // Rewrite me to not use fetchAndSubscribe.
    this.agent.fetchAndSubscribe(collection, docName, function(err, data, opstream) {
      if (err) {
        self._setSubscribed(collection, docName, false);
        return callback(err);
      }
      self._subscribeToStream(collection, docName, opstream);
      callback(null, data);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &#x27;sub&#x27;:
// Subscribe to a document. If the version is specified, we&#x27;ll catch the
// client up by sending all ops since the specified version.
//
// If the version is not specified, the client doesn&#x27;t have a snapshot
// yet. We&#x27;ll send them a snapshot at the most recent version and stream
// operations from that version.
this.<span class="apidocCodeKeywordSpan">_subscribe</span>(collection, docName, req.v, function(err, data) {
  if (err)
    callback(err);
  else
    callback(null, {data:data});
});
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype._subscribeToStream" id="apidoc.element.share.session.prototype._subscribeToStream">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>_subscribeToStream
        <span class="apidocSignatureSpan">(collection, docName, opstream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribeToStream = function (collection, docName, opstream) {
  var previous = this._setSubscribed(collection, docName, opstream);
  // Our set was rejected and our stream was destroyed, so just return
  if (previous) return;

  var self = this;
  // This should use the new streams API instead of the old one.
  opstream.on(&#x27;data&#x27;, onData);
  function onData(data) {
    self._sendOp(collection, docName, data);
  };
  opstream.once(&#x27;end&#x27;, function() {
    // Livedb has closed the op stream. What do we do here? Normally this
    // shouldn&#x27;t happen unless we&#x27;re cleaning up, so I&#x27;ll assume thats whats
    // happening now.
    self._setSubscribed(collection, docName, false);
    opstream.removeListener(&#x27;data&#x27;, onData);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // how it works, update that function too.
  // Yes, I know I&#x27;m a bad person.
  this.agent.subscribe(collection, docName, v, function(err, opstream) {
    if (err) {
      self._setSubscribed(collection, docName, false);
      return callback(err);
    }
    self.<span class="apidocCodeKeywordSpan">_subscribeToStream</span>(collection, docName, opstream);
    callback();
  });
} else {
  // Rewrite me to not use fetchAndSubscribe.
  this.agent.fetchAndSubscribe(collection, docName, function(err, data, opstream) {
    if (err) {
      self._setSubscribed(collection, docName, false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype.bulkSubscribe" id="apidoc.element.share.session.prototype.bulkSubscribe">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>bulkSubscribe
        <span class="apidocSignatureSpan">(request, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkSubscribe = function (request, callback) {
  // For each document there are three cases:
  // - The document is already subscribed. Do nothing
  // - The client doesn&#x27;t have a snapshot (v=null). We need to do a fetch then ...
  // - The client has a snapshot already (most common case) and is resubscribing. We need to subscribe.

  // This is a bulk fetch request for all documents that the client doesn&#x27;t have data for.
  var needFetch = {};

  // The eventual response.
  var response = {};

  for (var cName in request) {
    var docs = request[cName];
    // Every doc in the request will get a response.
    response[cName] = {};
    for (var docName in docs) {
      // Mark the subscription.
      this._setSubscribed(cName, docName, true);

      // Populate the bulk fetch request.
      if (docs[docName] == null) {
        needFetch[cName] = needFetch[cName] || [];
        needFetch[cName].push(docName);
      }
    }
  }

  var self = this;
  var agent = this.agent;

  // Next we do a bulkFetch on all the items that need a fetchin&#x27;. If no
  // documents need a fetch, this returns into the callback immediately.
  agent.bulkFetch(needFetch, function(err, snapshots) {
    if (err) {
      // For now, just abort the whole bundle on error. We could be more
      // neuanced about this, but I&#x27;ll wait for a use case.
      self._cancelBulk(request);
      return callback(err);
    }

    for (var cName in snapshots) {
      for (var docName in snapshots[cName]) {
        var snapshot = snapshots[cName][docName];
        // Set the version that we&#x27;ll subscribe to
        request[cName][docName] = snapshot.v;
        // Set the snapshot in the response
        response[cName][docName] = snapshot;
      }
    }

    agent.bulkSubscribe(request, function(err, streams) {
      if (err) {
        self._cancelBulk(request);
        return callback(err);
      }

      for (var cName in streams) {
        for (var docName in streams[cName]) {
          // Just give a thumbs up for the subscription.
          response[cName][docName] = response[cName][docName] || true;

          var v = request[cName][docName].v;
          self._subscribeToStream(cName, docName, streams[cName][docName]);
        }
      }

      callback(null, response);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Set the version that we&#x27;ll subscribe to
  request[cName][docName] = snapshot.v;
  // Set the snapshot in the response
  response[cName][docName] = snapshot;
}
    }

    agent.<span class="apidocCodeKeywordSpan">bulkSubscribe</span>(request, function(err, streams) {
if (err) {
  self._cancelBulk(request);
  return callback(err);
}

for (var cName in streams) {
  for (var docName in streams[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype.close" id="apidoc.element.share.session.prototype.close">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>close
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (err) {
  if (err) {
    console.warn(&#x27;Session closed due to error&#x27;, err);
    this.stream.emit(&#x27;error&#x27;, err);
  }
  if (this.closed) return;
  // This will emit &#x27;end&#x27;, which will call _cleanup
  this.stream.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.on(&#x27;close&#x27;, function(reason) {
    stream.push(null);
    stream.emit(&#x27;close&#x27;);
  });

  stream.on(&#x27;end&#x27;, function() {
    client.<span class="apidocCodeKeywordSpan">close</span>();
  });

  // Give the stream to sharejs
  return share.listen(stream);
}));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype.pump" id="apidoc.element.share.session.prototype.pump">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>pump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pump = function () {
  if (this.closed) return;

  var req = this.stream.read();
  var self = this;

  if (req != null) {
    if (typeof req === &#x27;string&#x27;) {
      try {
        req = JSON.parse(req);
      } catch(e) {
        console.warn(&#x27;Client sent invalid JSON&#x27;, e.stack);
        self.close(e);
      }
    }
    this._handleMessage(req, function(err, msg) {
      if (err || msg) self._reply(req, err, msg);

      // This is in a process.nextTick to avoid stack smashing attacks (since
      // sometimes this callback function is called synchronously).
      process.nextTick(function() {
        self.pump();
      });
    });
  } else {
    // Retry when there&#x27;s a message waiting for us.
    this.stream.once(&#x27;readable&#x27;, this.pump.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * (The useragent is available through all middleware)
 */
ShareInstance.prototype.listen = function(stream, req) {
var session = this.createSession(stream);
session.agent.trigger(&#x27;connect&#x27;, null, null, {stream: stream, req: req}, function(err) {
  if (err) return session.close(err);
  session.<span class="apidocCodeKeywordSpan">pump</span>();
});
return session.agent;
};

// Create and return REST middleware to access the documents
ShareInstance.prototype.rest = function() {
var rest = require(&#x27;./rest&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.session.prototype.subscribeStats" id="apidoc.element.share.session.prototype.subscribeStats">
        function <span class="apidocSignatureSpan">share.session.prototype.</span>subscribeStats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeStats = function () {
  var stats = {};

  for (var c in this.collections) {
    var count = 0;

    for (var d in this.collections[c]) {
      if (this.collections[c][d]) count++;
    }

    stats[c] = count;
  }

  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.types" id="apidoc.module.share.types">module share.types</a></h1>


    <h2>
        <a href="#apidoc.element.share.types.registerType" id="apidoc.element.share.types.registerType">
        function <span class="apidocSignatureSpan">share.types.</span>registerType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerType = function (type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.ottypes = {};
exports.registerType = function(type) {
  if (type.name) exports.ottypes[type.name] = type;
  if (type.uri) exports.ottypes[type.uri] = type;
};

exports.<span class="apidocCodeKeywordSpan">registerType</span>(require(&#x27;ot-json0&#x27;).type);
exports.registerType(require(&#x27;ot-text&#x27;).type);
exports.registerType(require(&#x27;ot-text-tp2&#x27;).type);

// The types register themselves on their respective types.
require(&#x27;./text-api&#x27;);
require(&#x27;./text-tp2-api&#x27;);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.useragent" id="apidoc.module.share.useragent">module share.useragent</a></h1>


    <h2>
        <a href="#apidoc.element.share.useragent.useragent" id="apidoc.element.share.useragent.useragent">
        function <span class="apidocSignatureSpan">share.</span>useragent
        <span class="apidocSignatureSpan">(instance, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useragent = function (instance, stream) {
  this.instance = instance;
  this.backend = instance.backend;

  this.stream = stream;
  this.sessionId = hat();

  this.connectTime = new Date();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.share.useragent.prototype" id="apidoc.module.share.useragent.prototype">module share.useragent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.share.useragent.prototype._filterQueryResults" id="apidoc.element.share.useragent.prototype._filterQueryResults">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>_filterQueryResults
        <span class="apidocSignatureSpan">(collection, results, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_filterQueryResults = function (collection, results, callback) {
  // The filter function is asyncronous. We can run all of the query results in parallel.
  var agent = this;
  async.each(results, function(data, innerCb) {
    agent.filterDoc(collection, data.docName, data, innerCb);
  }, function(error) {
    callback(error, results);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (err) return callback(err);

    collection = action.collection;
    query = action.query;

    agent.backend.queryFetch(collection, query, options, function(err, results, extra) {
      if (err) return callback(err);
      agent.<span class="apidocCodeKeywordSpan">_filterQueryResults</span>(collection, results, function(err, results) {
        if (err) return callback(err);
        callback(null, results, extra);
      });
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype._runFilters" id="apidoc.element.share.useragent.prototype._runFilters">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>_runFilters
        <span class="apidocSignatureSpan">(filters, collection, docName, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runFilters = function (filters, collection, docName, data, callback) {
  var self = this;
  async.eachSeries(filters, function(filter, next) {
    filter.call(self, collection, docName, data, next);
  }, function(error) {
    callback(error, error ? null : data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    filter.call(self, collection, docName, data, next);
  }, function(error) {
    callback(error, error ? null : data);
  });
};

UserAgent.prototype.filterDoc = function(collection, docName, data, callback) {
  return this.<span class="apidocCodeKeywordSpan">_runFilters</span>(this.instance.docFilters, collection, docName, data, callback
);
};
UserAgent.prototype.filterOp = function(collection, docName, data, callback) {
  return this._runFilters(this.instance.opFilters, collection, docName, data, callback);
};

// This is only used by bulkFetch, but its enough logic that I prefer to
// separate it out.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.bulkFetch" id="apidoc.element.share.useragent.prototype.bulkFetch">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>bulkFetch
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkFetch = function (requests, callback) {
  var agent = this;

  if (bulkFetchRequestsEmpty(requests)) return callback(null, {});

  if (this.instance._hasMiddleware(&#x27;bulk fetch&#x27;) || !this.instance._hasMiddleware(&#x27;fetch&#x27;)) {
    agent.trigger(&#x27;bulk fetch&#x27;, null, null, {requests:requests}, function(err, action) {
      if (err) return callback(err);
      requests = action.requests;

      agent.backend.bulkFetch(requests, function(err, data) {
        if (err) return callback(err);

        agent.filterDocs(data, callback);
      });
    });
  } else {
    // Could implement this using async...
    throw Error(&#x27;If you have fetch middleware you need to also make bulk fetch middleware&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var self = this;
var agent = this.agent;

// Next we do a bulkFetch on all the items that need a fetchin&#x27;. If no
// documents need a fetch, this returns into the callback immediately.
agent.<span class="apidocCodeKeywordSpan">bulkFetch</span>(needFetch, function(err, snapshots) {
  if (err) {
    // For now, just abort the whole bundle on error. We could be more
    // neuanced about this, but I&#x27;ll wait for a use case.
    self._cancelBulk(request);
    return callback(err);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.bulkSubscribe" id="apidoc.element.share.useragent.prototype.bulkSubscribe">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>bulkSubscribe
        <span class="apidocSignatureSpan">(requests, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkSubscribe = function (requests, callback) {
  var agent = this;
  // Use a bulk subscribe to check everything in one go.
  agent.trigger(&#x27;bulk subscribe&#x27;, null, null, {requests: requests}, function(err, action) {
    if (err) return callback(err);
    agent.backend.bulkSubscribe(action.requests, function(err, streams) {
      callback(err, err ? null : agent.wrapOpStreams(streams));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Set the version that we&#x27;ll subscribe to
  request[cName][docName] = snapshot.v;
  // Set the snapshot in the response
  response[cName][docName] = snapshot;
}
    }

    agent.<span class="apidocCodeKeywordSpan">bulkSubscribe</span>(request, function(err, streams) {
if (err) {
  self._cancelBulk(request);
  return callback(err);
}

for (var cName in streams) {
  for (var docName in streams[cName]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.fetch" id="apidoc.element.share.useragent.prototype.fetch">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>fetch
        <span class="apidocSignatureSpan">(collection, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (collection, docName, callback) {
  var agent = this;

  agent.trigger(&#x27;fetch&#x27;, collection, docName, function(err, action) {
    if (err) return callback(err);
    collection = action.collection;
    docName = action.docName;

    agent.backend.fetch(collection, docName, function(err, data) {
      if (err) return callback(err);
      if (data) {
        agent.filterDoc(collection, docName, data, callback);
      } else {
        callback(null, data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.subscribe(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.<span class="apidocCodeKeywordSpan">fetch</span>(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
name is a new GUID), you can immediately call **doc.create(type, data,
callback)**.

&#x3e; There&#x27;s a secret 4th option - if you&#x27;re doing server-side rendering, you can
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.fetchAndSubscribe" id="apidoc.element.share.useragent.prototype.fetchAndSubscribe">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>fetchAndSubscribe
        <span class="apidocSignatureSpan">(collection, docName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetchAndSubscribe = function (collection, docName, callback) {
  var agent = this;
  agent.trigger(&#x27;fetch&#x27;, collection, docName, function(err, action) {
    if (err) return callback(err);
    agent.trigger(&#x27;subscribe&#x27;, action.collection, action.docName, function(err, action) {
      if (err) return callback(err);

      collection = action.collection;
      docName = action.docName;
      agent.backend.fetchAndSubscribe(action.collection, action.docName, function(err, data, stream) {
        if (err) return callback(err);
        agent.filterDoc(collection, docName, data, function (err, data) {
          if (err) return callback(err);
          var wrappedStream = agent.wrapOpStream(collection, docName, stream);
          callback(null, data, wrappedStream);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return callback(err);
    }
    self._subscribeToStream(collection, docName, opstream);
    callback();
  });
} else {
  // Rewrite me to not use fetchAndSubscribe.
  this.agent.<span class="apidocCodeKeywordSpan">fetchAndSubscribe</span>(collection, docName, function(err, data, opstream) {
    if (err) {
      self._setSubscribed(collection, docName, false);
      return callback(err);
    }
    self._subscribeToStream(collection, docName, opstream);
    callback(null, data);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.filterDoc" id="apidoc.element.share.useragent.prototype.filterDoc">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterDoc
        <span class="apidocSignatureSpan">(collection, docName, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterDoc = function (collection, docName, data, callback) {
  return this._runFilters(this.instance.docFilters, collection, docName, data, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  work--;
  if (work === 0 &#x26;&#x26; callback) callback(null, data);
}

for (var cName in data) {
  for (var docName in data[cName]) {
    work++;
    this.<span class="apidocCodeKeywordSpan">filterDoc</span>(cName, docName, data[cName][docName], function(err) {
      if (err &#x26;&#x26; callback) {
        callback(err);
        callback = null;
      }
      // Clean up call stack
      process.nextTick(done);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.filterDocs" id="apidoc.element.share.useragent.prototype.filterDocs">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterDocs
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterDocs = function (data, callback) {
  var work = 1;
  var done = function() {
    work--;
    if (work === 0 &#x26;&#x26; callback) callback(null, data);
  }

  for (var cName in data) {
    for (var docName in data[cName]) {
      work++;
      this.filterDoc(cName, docName, data[cName][docName], function(err) {
        if (err &#x26;&#x26; callback) {
          callback(err);
          callback = null;
        }
        // Clean up call stack
        process.nextTick(done);
      });
    }
  }
  done();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    agent.trigger(&#x27;bulk fetch&#x27;, null, null, {requests:requests}, function(err, action) {
      if (err) return callback(err);
      requests = action.requests;

      agent.backend.bulkFetch(requests, function(err, data) {
        if (err) return callback(err);

        agent.<span class="apidocCodeKeywordSpan">filterDocs</span>(data, callback);
      });
    });
  } else {
    // Could implement this using async...
    throw Error(&#x27;If you have fetch middleware you need to also make bulk fetch middleware&#x27;);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.filterOp" id="apidoc.element.share.useragent.prototype.filterOp">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterOp
        <span class="apidocSignatureSpan">(collection, docName, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterOp = function (collection, docName, data, callback) {
  return this._runFilters(this.instance.opFilters, collection, docName, data, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

emitter.onOp = function(data) {
  var collection = data.collection;
  var docName = data.docName;
  // No need to send from the query if the doc is also subscribed
  if (self._isSubscribed(collection, docName)) return;
  // ShareJS filter middleware that might be doing access control or something
  agent.<span class="apidocCodeKeywordSpan">filterOp</span>(collection, docName, data, function(err, filtered) {
    if (err) return emitter.onError(err);
    self._sendOp(collection, docName, filtered);
  });
};

var data = self._processQueryResults(req.c, results, qopts);
callback(null, {id: qid, data: data, extra: extra});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.filterOps" id="apidoc.element.share.useragent.prototype.filterOps">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>filterOps
        <span class="apidocSignatureSpan">(collection, docName, ops, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterOps = function (collection, docName, ops, callback) {
  if (!ops) return callback();
  var agent = this;
  var i = 0;
  (function next(err) {
    if (err) return callback(err);
    var op = ops[i++];
    if (op) {
      // Clean up call stack. Would it be better to modulus the iterator and
      // only introduce next tick every nth iteration?
      process.nextTick(function() {
        agent.filterOp(collection, docName, op, next);
      });
    } else {
      callback(null, ops);
    }
  })();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     error == &#x22;Document not found!&#x22;;
*   });
*
* In a filter `this` is the user agent.
*
* Similarily we can filter the operations that a client can see
*
*   instance.<span class="apidocCodeKeywordSpan">filterOps</span>(function(collection, docName, opData, next) {
*     if (opData.op == &#x27;cheat&#x27;)
*       next(&#x22;Not on my watch!&#x22;);
*     else
*       next();
*     }
*   });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.getOps" id="apidoc.element.share.useragent.prototype.getOps">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>getOps
        <span class="apidocSignatureSpan">(collection, docName, start, end, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOps = function (collection, docName, start, end, callback) {
  var agent = this;

  agent.trigger(&#x27;get ops&#x27;, collection, docName, {start:start, end:end}, function(err, action) {
    if (err) return callback(err);

    agent.backend.getOps(action.collection, action.docName, start, end, function(err, results) {
      if (err) return callback(err);

      agent.filterOps(collection, docName, results, callback);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var from = 0, to = null;

  var query = url.parse(req.url, true).query;

  if (query &#x26;&#x26; query.from) from = parseInt(query.from)|0;
  if (query &#x26;&#x26; query.to) to = parseInt(query.to)|0;

  req._shareAgent.<span class="apidocCodeKeywordSpan">getOps</span>(req.params.cName, req.params.docName, from, to, function(err
, ops) {
    if (err)
      sendError(res, err);
    else
      sendJSON(res, ops);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.query" id="apidoc.element.share.useragent.prototype.query">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>query
        <span class="apidocSignatureSpan">(collection, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (collection, query, options, callback) {
  var agent = this;
  agent.trigger(&#x27;query&#x27;, collection, null, {query: query, options: options}, function(err, action) {
    if (err) return callback(err);

    collection = action.collection;
    query = action.query;

    agent.backend.query(collection, query, options, function(err, emitter, results, extra) {
      if (err) return callback(err);

      // Override emitDiff to filter all inserted items
      emitter.emitDiff = function(diff) {
        async.each(diff, function(item, cb) {
          if (item.type === &#x27;insert&#x27;) {
            agent._filterQueryResults(collection, item.values, cb);
            return;
          }
          cb();
        }, function(err) {
          if (err) return emitter.emitError(err);
          emitter.onDiff(diff);
        });
      };

      // TODO: This is buggy. If the emitter emits a diff during a slow piece of
      // middleware, it&#x27;ll be lost.
      agent._filterQueryResults(collection, results, function(err, results) {
        // Also if there&#x27;s an error here, the emitter is never removed.
        if (err) return callback(err);
        callback(null, emitter, results, extra);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      console.warn(&#x27;:,(&#x27;);
    }
    if (editorElem) contentArea.appendChild(editorElem);
  });
};

//q = sjs.<span class="apidocCodeKeywordSpan">query</span>(&#x27;users&#x27;, {&#x27;data.x&#x27;:5}, true, function(err, data) {
console.log(err, data); });
query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{&#x22;x&#x22;:5}}, {docMode:&#x27;sub&#x27;});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, &#x27;users&#x27;, {docMode:&#x27;fetch&#x27;});
//query = sjs.createSubscribeQuery(&#x27;stories&#x27;, {$query:{}}, {autoFetch:true});

//query = sjs.createSubscribeQuery(&#x27;players&#x27;, {&#x22;$orderby&#x22;:{&#x22;data.score&#x22;:-1},&#x22;$limit&#x22;:5}, {
autoFetch:true});
//query = sjs.createSubscribeQuery(&#x27;users&#x27;, {$query:{}}, {autoFetch:true, source:&#x27;clock&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.queryFetch" id="apidoc.element.share.useragent.prototype.queryFetch">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>queryFetch
        <span class="apidocSignatureSpan">(collection, query, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queryFetch = function (collection, query, options, callback) {
  var agent = this;
  // Should we emit &#x27;query&#x27; or &#x27;query fetch&#x27; here?
  agent.trigger(&#x27;query&#x27;, collection, null, {query:query, fetch:true, options: options}, function(err, action) {
    if (err) return callback(err);

    collection = action.collection;
    query = action.query;

    agent.backend.queryFetch(collection, query, options, function(err, results, extra) {
      if (err) return callback(err);
      agent._filterQueryResults(collection, results, function(err, results) {
        if (err) return callback(err);
        callback(null, results, extra);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


    // ********* Queries **********

    case &#x27;qfetch&#x27;:
      // Fetch the results of a query. This does not subscribe to the query or
      // anything, its just a once-off query fetch.
      agent.<span class="apidocCodeKeywordSpan">queryFetch</span>(index, req.q, qopts, function(err, results, extra) {
if (err) return callback(err);

// If the query subscribes to documents, the callback isn&#x27;t called
// until all the documents are subscribed.
var data = self._processQueryResults(req.c, results, qopts);

callback(null, {id:qid, data:data, extra:extra});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.submit" id="apidoc.element.share.useragent.prototype.submit">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>submit
        <span class="apidocSignatureSpan">(collection, docName, opData, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">submit = function (collection, docName, opData, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  var agent = this;
  agent.trigger(&#x27;submit&#x27;, collection, docName, {opData: opData, channelPrefix:null}, function(err, action) {
    if (err) return callback(err);

    collection = action.collection;
    docName = action.docName;
    opData = action.opData;
    options.channelPrefix = action.channelPrefix;

    if (!opData.preValidate) opData.preValidate = agent.instance.preValidate;
    if (!opData.validate) opData.validate = agent.instance.validate;

    agent.backend.submit(collection, docName, opData, options, function(err, v, ops, snapshot) {
      if (err) return callback(err);
      agent.trigger(&#x27;after submit&#x27;, collection, docName, {opData: opData, snapshot: snapshot}, function(err) {
        if (err) return callback(err);
        agent.filterOps(collection, docName, ops, function(err, filteredOps) {
          if (err) return callback(err);
          callback(null, v, filteredOps);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
  });

  var submit = function(req, res, opData, sendOps) {
    // The backend allows the version to be unspecified - it assumes the most
    // recent version in that case. This is useful behaviour when you want to
    // create a document.
    req._shareAgent.<span class="apidocCodeKeywordSpan">submit</span>(req.params.cName, req.params.docName, opData, {}, function
(err, v, ops) {
if (err) return sendError(res, err);

res.setHeader(&#x27;X-OT-Version&#x27;, v);
if (sendOps)
  sendJSON(res, ops);
else
  send200(res);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.subscribe" id="apidoc.element.share.useragent.prototype.subscribe">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(collection, docName, version, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (collection, docName, version, callback) {
  var agent = this;
  agent.trigger(&#x27;subscribe&#x27;, collection, docName, {version:version}, function(err, action) {
    if (err) return callback(err);
    collection = action.collection;
    docName = action.docName;
    version = action.version;
    agent.backend.subscribe(collection, docName, version, function(err, stream) {
       callback(err, err ? null : agent.wrapOpStream(collection, docName, stream));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Normally you will create a document object by calling
**connection.get(collection, docname)**. Destroy the document reference using
**doc.destroy()**.

Documents start in a dumb, inert state. You have three options to get started:

- Normally, you want to call **doc.<span class="apidocCodeKeywordSpan">subscribe</span>(callback)**. This will fetch the
current data from the server and subscribe the document object to a feed of
changes from other clients. (If you don&#x27;t want to be subscribed anymore, call
**doc.unsubscribe([callback])**).
- If you don&#x27;t want a live feed of changes, call **doc.fetch(callback)** to get
the data from the server. Your local document will be updated automatically
every time you submit an operation.
- If you know the document doesn&#x27;t exist on the server (for example the doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.trigger" id="apidoc.element.share.useragent.prototype.trigger">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>trigger
        <span class="apidocSignatureSpan">(action, collection, docName, request, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trigger = function (action, collection, docName, request, callback) {
  if (typeof request === &#x27;function&#x27;) {
    callback = request;
    request = {};
  }

  request.agent = this;
  request.action = action;
  if (collection) request.collection = collection;
  if (docName) request.docName = docName;
  request.backend = this.backend;

  this.instance._trigger(request, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * through to any connect() middleware. This is useful for inspecting cookies
 * or an express session or whatever on the request object in your middleware.
 *
 * (The useragent is available through all middleware)
 */
ShareInstance.prototype.listen = function(stream, req) {
  var session = this.createSession(stream);
  session.agent.<span class="apidocCodeKeywordSpan">trigger</span>(&#x27;connect&#x27;, null, null, {stream: stream, req: req},
function(err) {
    if (err) return session.close(err);
    session.pump();
  });
  return session.agent;
};

// Create and return REST middleware to access the documents
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.wrapOpStream" id="apidoc.element.share.useragent.prototype.wrapOpStream">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>wrapOpStream
        <span class="apidocSignatureSpan">(collection, docName, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapOpStream = function (collection, docName, stream) {
  var opTransformStream = new OpTransformStream(this, collection, docName, stream);
  stream.pipe(opTransformStream);
  return opTransformStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * `streams` is a map `collection -&#x3e; docName -&#x3e; stream`. It returns the same map
 * with the streams wrapped.
 */
UserAgent.prototype.wrapOpStreams = function(streams) {
  for (var cName in streams) {
    for (var docName in streams[cName]) {
      streams[cName][docName] = this.<span class="apidocCodeKeywordSpan">wrapOpStream</span>(cName, docName, streams[cName][docName
]);
    }
  }
  return streams;
};


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.share.useragent.prototype.wrapOpStreams" id="apidoc.element.share.useragent.prototype.wrapOpStreams">
        function <span class="apidocSignatureSpan">share.useragent.prototype.</span>wrapOpStreams
        <span class="apidocSignatureSpan">(streams)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapOpStreams = function (streams) {
  for (var cName in streams) {
    for (var docName in streams[cName]) {
      streams[cName][docName] = this.wrapOpStream(cName, docName, streams[cName][docName]);
    }
  }
  return streams;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// requests is a map from cName -&#x3e; docName -&#x3e; version.
UserAgent.prototype.bulkSubscribe = function(requests, callback) {
  var agent = this;
  // Use a bulk subscribe to check everything in one go.
  agent.trigger(&#x27;bulk subscribe&#x27;, null, null, {requests: requests}, function(err, action) {
    if (err) return callback(err);
    agent.backend.bulkSubscribe(action.requests, function(err, streams) {
      callback(err, err ? null : agent.<span class="apidocCodeKeywordSpan">wrapOpStreams</span>(streams));
    });
  });
};


// DEPRECATED - just call fetch() then subscribe() yourself.
UserAgent.prototype.fetchAndSubscribe = function(collection, docName, callback) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
